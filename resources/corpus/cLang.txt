ccc,CLanguage
/**
 * @file 	main.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Archivo principal.
 * 			Inicia y pone a correr la maquian de estados (fsm).
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "fsm.h"
#include "queue.h"

#include <stdio.h>
#include <stdlib.h>

/*******************************************************************************
 *******************************************************************************
                                    MAIN
 *******************************************************************************
 ******************************************************************************/

int main(void)
{
	event_t evento;

	if (!inicializarFsm())
		return 1;

	while ((evento = queueSiguienteEvento()))
	{
		if (evento != NADA)
		{
			fsm(evento);
		}

		fixHighCpuUsage();
	}

	destruirQueue();

	printf("\nGracias por jugar <3\n");

	return 0;
}

/**
 * @file 	queue.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo queue.
 * 			Funciones para el manejo de la cola de eventos.
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "queue.h"

#include <stdlib.h>

/*******************************************************************************
 * ENUMERATIONS AND STRUCTURES AND TYPEDEFS
 ******************************************************************************/

// Estructura del nodo
typedef struct nodeT
{
	event_t data;
	struct nodeT *next;
} node_t;

/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/**
 * @brief Borra un elemento de la cola
 *
 */
static void borrarElemento(void);

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

static node_t *front = NULL, *back = NULL;

/*******************************************************************************
 *******************************************************************************
                        GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void queueInsertar(event_t nuevo)
{
	node_t *temp = (node_t *)malloc(sizeof(node_t));

	temp->data = nuevo;

	if (front == NULL)
	{
		front = temp;
		front->next = NULL;
	}
	else if (back == NULL)
	{
		back = temp;
		front->next = back;
		back->next = NULL;
	}
	else
	{
		back->next = temp;
		back = back->next;
	}
}

bool queueVacia(void)
{
	return front == NULL;
}

event_t queueSiguienteEvento(void)
{
	if (front == NULL)
	{
		return NADA;
	}
	else
	{
		event_t r = front->data;
		borrarElemento();
		return r;
	}
}

void destruirQueue(void)
{
	while (front != NULL)
	{
		queueSiguienteEvento();
	}
}

/*******************************************************************************
 *******************************************************************************
                        LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

static void borrarElemento(void)
{
	if (front != NULL)
	{
		node_t *temp = front;
		front = front->next;
		free(temp);
		if (front == NULL)
		{
			back = NULL;
		}
	}
}

/**
 * @file 	ranking.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo ranking.
 * 			Funciones de interaccion con el ranking de jugadores.
 * 			Permite trabajar con el txt correspondiente fácilmente,
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "ranking.h"
#include "queue.h"

/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

// Largo maximo de una linea del txt
#define MAX_LEN 100

/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/**
 * @brief Lee el archivo de ranking y recarga arrays internos.
 *
 */
static void recargarRanking(void);

/**
 * @brief Reordena arrays internos con informacion de ranking, quedando el de mayor puntaje primero, por orden alfabetico.
 *
 */
static void ordenarRanking(void);

/**
 * @brief Escribe los arrays internos al txt de ranking
 *
 */
static void writeRanking(void);

/**
 * @brief Crea txt de ranking si no existe
 *
 */
static void createRankingFile(void);

/**
 * @brief Realoca memoria, verificando si fue posible hacerlo
 *
 * @param p puntero a memoria sin realocar(puede ser nulo)
 * @param n cantidad de bytes que se desean en el nuevo array
 * @return void* puntero a memoria realocada
 */
static void *realocar(void *p, size_t n);

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

// Nombre del archivo de ranking
static char *strRanking = "ranking.txt";
// Nombre del archivo temporal
static char *strTemp = "temp.txt";

// Handler del archivo de ranking
FILE *handlerRanking = NULL;
// Handler del archivo temporal
FILE *handlerTemp = NULL;

// Punteros a nombres
static char **names = NULL;
// Puntero a scores
static unsigned long long *scores = NULL;

// String temporal
static char tempStr[MAX_LEN];

// Contador de lineas del txt
static uint lineNumber = 0;

/*******************************************************************************
 *******************************************************************************
                        GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void iniciarRanking(void)
{
	lineNumber = 0;

	createRankingFile();

	if ((handlerRanking = fopen(strRanking, "r")) == NULL)
		printf("Error opening ranking.txt");

	recargarRanking();

	fclose(handlerRanking);
}

void actualizarRanking(char *name, unsigned long long score)
{
	int i;
	bool player_exists = false;

	if (lineNumber)
	{
		// Veo si el jugador esta en el ranking
		for (i = 0; i < lineNumber && !player_exists; i++)
		{

			// Si el nombre coincide...
			if (strcmp(names[i], name) == 0)
			{
				// Actualiza el score
				scores[i] = score;
				player_exists = true;
			}
		}
	}

	// Si el jugador no existe en el ranking, lo agrego al final
	if (!player_exists)
	{
		names = (char **)realocar(names, sizeof(char *) * (lineNumber + 1));
		names[lineNumber] = (char *)realocar(NULL, strlen(name) * sizeof(char) + 1);
		strcpy(names[lineNumber], name);

		scores = (unsigned long long *)realocar(scores, sizeof(unsigned long long) * (lineNumber + 1));
		scores[lineNumber] = score;

		lineNumber++;
	}

	ordenarRanking();
}

void desiniciarRanking(void)
{
	// Escribe al archivo
	writeRanking();

	// Liberacion de memoria
	int i;
	for (i = 0; i < lineNumber; i++)
		free(names[i]);

	free(names);
	free(scores);
}

bool verificarJugadorRanking(char *name)
{
	// Ranking vacio
	if (!lineNumber)
		return false;

	int i;
	bool exists;
	for (i = 0, exists = false; i < lineNumber && !exists; i++)
		exists = strcmp(names[i], name) == 0;

	return exists;
}

unsigned long long getJugadorRankingPuntos(char *name)
{
	int i;
	bool exists;
	unsigned long long score = 0;

	for (i = 0, exists = false; i < lineNumber && !exists; i++)
	{
		// Si el nombre coincide...
		if (strcmp(names[i], name) == 0)
		{
			// Carga el score
			score = scores[i];
			exists = true;
		}
	}

	return score;
}

uint getRankingLineas(void)
{
	return lineNumber;
}

char **getRankingNombres(void)
{
	return names;
}

unsigned long long *getRankingPuntos(void)
{
	return scores;
}

/*******************************************************************************
 *******************************************************************************
                        LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

static void recargarRanking(void)
{
	lineNumber = 0;

	while (fgets(tempStr, MAX_LEN, handlerRanking) != NULL)
	{
		char *p = strchr(tempStr, '\n');
		while (p != NULL)
		{
			*p = '\0'; // Saco todos los saltos de linea
			p = strchr(tempStr, '\n');
		}

		char *tempPtr = strtok(tempStr, " ");										// Apunto al nombre
		names = (char **)realocar(names, sizeof(char *) * (lineNumber + 1));		// Reservo memoria para un puntero
		names[lineNumber] = (char *)realocar(NULL, strlen(tempPtr) * sizeof(char) + 1); // Reservo memoria para el nombre
		strcpy(names[lineNumber], tempPtr);

		tempPtr = strtok(NULL, " ");																	// Apunto a los puntos
		scores = (unsigned long long *)realocar(scores, sizeof(unsigned long long) * (lineNumber + 1)); // Reservo memoria para un score
		scores[lineNumber] = strtoul(tempPtr, NULL, 10);

		lineNumber++;
	}
}

static void ordenarRanking(void)
{
	int i, j;
	unsigned long long tempScore;

	for (i = 0; i < (lineNumber - 1); i++)
	{
		for (j = 0; j < (lineNumber - i - 1); j++)
		{
			// Si el primer score es menor, o si es igual al siguiente pero predomina orden alfabetico...
			if ((scores[j] < scores[j + 1]) || ((scores[j] == scores[j + 1]) && (strcmp(names[j], names[j + 1]) > 0)))
			{
				// Backup del menor
				strcpy(tempStr, names[j]);
				tempScore = scores[j];

				// El mayor se pone en la posicion del menor
				strcpy(names[j], names[j + 1]);
				scores[j] = scores[j + 1];

				// El backup se pone en la posicion del mayor
				strcpy(names[j + 1], tempStr);
				scores[j + 1] = tempScore;
			}
		}
	}
}

static void writeRanking(void)
{
	int i;

	// Crea archivo temporal
	if ((handlerTemp = fopen(strTemp, "w")) == NULL)
		printf("Error opening temp.txt");

	if (lineNumber)
	{
		// Copia lo nuevo en temp.txt
		for (i = 0; i < lineNumber; i++)
			fprintf(handlerTemp, "%s %lld\n", names[i], scores[i]);
	}

	remove(strRanking);
	rename(strTemp, strRanking);

	fclose(handlerTemp);
}

static void createRankingFile(void)
{
	// crea el archivo, si no lo estaba
	FILE *pFile;
	if ((pFile = fopen(strRanking, "a")) == NULL)
	{
		printf("Error creando %s", strRanking);
	}
	fclose(pFile);
}

static void *realocar(void *p, size_t n)
{
	void *aux = realloc(p, n);
	if (aux == NULL)
	{
		perror("Error en ranking.c al realocar memoria\n");
		free(p);
		queueInsertar(FORCE_SALIR);
	}
	return aux;
}
/**
 * @file 	allegro_stuff.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo allegro_stuff. Se encarga de todas las 
 * 			inicializaciones y desinicializaciones relativas a allegro5 y
 * 			sus addons.
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "allegro_stuff.h"
#include "geometry.h"
#include <string.h>

#include "./algif5/algif.h"

/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

// Altura de la fuente
#define FONT_HEIGHT 16

// Nombres de los stream files
#define SOUND_STREAM_FILE_CREDITS "credits_theme"
#define SOUND_STREAM_FILE_MAIN "main_menu_theme"
#define SOUND_STREAM_FILE_PAUSE "pause_menu_theme"
#define SOUND_STREAM_FILE_PLAYING "playing_theme"
#define SOUND_STREAM_FILE_RANKING "ranking_theme"
#define SOUND_STREAM_FILE_RICK "rick"
#define SOUND_STREAM_FILE_GAME_OVER "game_over"

#define FONT_FILE_NAME "PublicPixel.ttf"

// Nombres de los sprites
#define SPRITE_HEART "minecraft_heart"
#define SPRITE_BACKGROUND "sprite_background"
#define SPRITE_CAR "sprite_cars"
#define SPRITE_FROG "sprite_frog"
#define SPRITE_LOG "sprite_log"
#define SPRITE_TURTLES "sprite_turtles"
#define SPRITE_MENU_HOME_BACK "sprite_menu_home_background"
#define SPRITE_MENU_HOME "sprite_menu_home"
/*
#define SPRITE_MENU_DIFF_BACK		"sprite_menu_home_background"
#define SPRITE_MENU_DIFF			"sprite_menu_home"
#define SPRITE_MENU_PAUSE_BACK		"sprite_menu_home_background"
#define SPRITE_MENU_PAUSE			"sprite_menu_home"
*/
#define SPRITE_MENU_DIFF_BACK "sprite_menu_diff_background"
#define SPRITE_MENU_DIFF "sprite_menu_diff"
#define SPRITE_MENU_PAUSE_BACK "sprite_menu_pause_background"
#define SPRITE_MENU_PAUSE "sprite_menu_pause"
#define SPRITE_MENU_GAME_OVER_BACK "sprite_menu_gameover_background"
#define SPRITE_MENU_GAME_OVER "sprite_menu_gameover"
#define SPRITE_CREDITS "sprite_credits"
#define SPRITE_NAME "sprite_name"
#define SPRITE_TUTORIAL "sprite_tutorial2"
#define SPRITE_ICON "icon"
#define SPRITE_DEAD "sprite_dead"
#define SPRITE_BORDER "sprite_border"
#define SPRITE_SPLASH "sprite_splash"
#define SPRITE_COIN "sprite_coin"

// Extensiones
#define EXTENSION_SOUND_SAMPLE ".wav"
#define EXTENSION_SOUND_STREAM ".opus"
#define EXTENSION_SPRITES ".png"

// Local paths
#define PATH_SOUND_STREAMS "../res/sounds/streams/"
#define PATH_SOUND_SAMPLES "../res/sounds/samples/"
#define PATH_FONTS "../res/fonts/"
#define PATH_SPRITES "../res/sprites/"
#define PATH_GIFS "../res/gifs/"

#define GLOBAL_STREAM_VOLUME (double)0.5

/*******************************************************************************
 * ENUMERATIONS AND STRUCTURES AND TYPEDEFS
 ******************************************************************************/

typedef struct
{
	////timer que actualiza cada 1/60 segundos (60fps)
	ALLEGRO_TIMER *timer;

	// cola de eventos
	ALLEGRO_EVENT_QUEUE *queue;

	// display
	ALLEGRO_DISPLAY *disp;

	// fuente builtin
	ALLEGRO_FONT *font;
	int font_h; // altura de un caracter
	int font_w; // ancho de un caracter

	// variable evento
	ALLEGRO_EVENT event;

	// flag para salir el programa
	bool done;
	// flag para renderizar
	bool redraw;

} allegro_t;

typedef struct
{
	ALLEGRO_AUDIO_STREAM *stream;
	unsigned char stream_state;

	struct
	{
		ALLEGRO_SAMPLE *jump;
		ALLEGRO_SAMPLE *crash;
		ALLEGRO_SAMPLE *goal;
		ALLEGRO_SAMPLE *low_time;
		ALLEGRO_SAMPLE *click;
		ALLEGRO_SAMPLE *bonus;
		ALLEGRO_SAMPLE *run_completed;
		ALLEGRO_SAMPLE *drowned;
		ALLEGRO_SAMPLE *menu_enter;
		ALLEGRO_SAMPLE *new_max_score;
		ALLEGRO_SAMPLE *exiting;
		ALLEGRO_SAMPLE *no_time;
		ALLEGRO_SAMPLE *coin_drop;
	} samples;

} sounds_t;

enum SOUND_STREAM_STATES
{
	SOUND_STREAM_STATE_NO_INIT,
	SOUND_STREAM_STATE_INIT,
	SOUND_STREAM_STATE_PAUSE,
	SOUND_STREAM_STATE_PLAY
};

/*******************************************************************************
 * VARIABLES WITH GLOBAL SCOPE
 ******************************************************************************/

// estructura con punteros a sprites
sprites_t sprites;

/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/**
 * @brief Copia parte de un spritesheet y lo devuelve como un nuevo bitmap
 *
 * @param source_bmp Puntero al bitmap original
 * @param x top left 'x' coord
 * @param y top left 'y' coord
 * @param w wide
 * @param h heigth
 * @param source_bmp
 * @return ALLEGRO_BITMAP*
 */
static ALLEGRO_BITMAP *sprite_cut(ALLEGRO_BITMAP *source_bmp, int x, int y, int w, int h);

/**
 * @brief Inicializa los sprites a usar
 *
 */
static void sprites_init(void);

/**
 * @brief Devuelve puntero a string con el path de un sprite dado
 *
 * @param file_name Nombre el sprite, sin extension
 * @return char* Puntero al path
 */

/**
 * @brief Devuelve puntero a string con el path de un sprite dado.
 * Permite destruir un string creado con la misma funcion
 *
 * @param file_name Nombre del sprite, sin extension
 * @param prev_str String previamente creado, de ser necesario.
 * @return char* Puntero al path nuevo
 */
static char *make_sprite_path(char *file_name, char *prev_str);

/**
 * @brief Destruye los sprites a usar
 *
 */
static void sprites_deinit(void);

/**
 * @brief Inicializa audios
 *
 */
static void audio_init(void);

/**
 * @brief Desinicializa audios
 *
 */
static void audio_deinit(void);

/**
 * @brief Inicialzia el stream (musica)
 *
 * @param file Nombre del archivo (sin extension, sin path)
 * @param gain Ganancia (1.0 no afecta)
 * @return true Inicializacion correcta
 * @return false Error en la inicializacion
 */
static bool init_audio_stream(const char *file, float gain);

/**
 * @brief Inicializa un sample (efecto)
 *
 * @param sample Sample a inicializar
 * @param file Nombre del archivo (sin extension, sin path)
 * @return true Inicializacion correcta
 * @return false Error en la inicializacion
 */
static bool init_sample(ALLEGRO_SAMPLE **sample, const char *file);

/**
 * @brief
 *
 */
static void rick_init(void);

/**
 * @brief
 *
 */
static void rick_deinit(void);

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

// variables principales de allegro
static allegro_t allegro_vars;

// Ultima tecla presionada
static unsigned char last_key;

// variable con los sonidos/musicas del juego
static sounds_t sounds;

// nombre del ultimo stream inicializado
static char last_init_stream[30];

static ALGIF_ANIMATION *rick;

static char rick_prev_stream[30];

static bool rick_flag;

static ALLEGRO_MONITOR_INFO monitor_info;

static double stream_gain = GLOBAL_STREAM_VOLUME; //ganancia para musica y efectos
static double last_stream_gain = GLOBAL_STREAM_VOLUME; //ultima ganancia antes del mute

static bool display_state = false;

//Para retener ultima posicion de ventana antes de recrearla
static int window_x, window_y;

/*******************************************************************************
 *******************************************************************************
            GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void must_init(bool test, const char *description)
{
	if (!test)
	{
		printf("~no se pudo inicializar %s~\n", description);
		while (true)
			;
	}
}

void allegro_inits(void)
{
	must_init(al_init(), "allegro");
	must_init(al_install_keyboard(), "keyboard");
	must_init(al_install_mouse(), "mouse");
	must_init(al_init_image_addon(), "image");
	al_init_font_addon();
	must_init(al_init_ttf_addon(), "ttf addon");

	// timer que actualiza cada 1/60 segundos (60fps)
	allegro_vars.timer = al_create_timer(1.0 / FPS);
	must_init(allegro_vars.timer, "timer");

	// cola de eventos
	allegro_vars.queue = al_create_event_queue();
	must_init(allegro_vars.queue, "queue");

	// Inicializa los spritesheets.
	sprites_init();

	// para dibujar figuras primitivas (círculos, rectángulos, líneas, rellenos o no, etc.)
	must_init(al_init_primitives_addon(), "primitives");

	// registra eventos posibles
	al_register_event_source(allegro_vars.queue, al_get_keyboard_event_source());
	al_register_event_source(allegro_vars.queue, al_get_timer_event_source(allegro_vars.timer));
	al_register_event_source(allegro_vars.queue, al_get_mouse_event_source());

	// flag para salir el programa
	allegro_vars.done = false;
	// flag para renderizar
	allegro_vars.redraw = false;

	// audio
	must_init(al_install_audio(), "audio");
	must_init(al_init_acodec_addon(), "audio codecs");
	must_init(al_reserve_samples(16), "reserve samples");

	audio_init();

	rick_init();

	must_init(al_get_monitor_info(0, &monitor_info), "getting monitor info");

	// creacion del display
	allegro_reinit_display();

	// inicializa timer
	al_start_timer(allegro_vars.timer);
}

void allegro_deinits(void)
{
	rick_deinit();
	sprites_deinit();
	audio_deinit();
	
	if(display_state)
	{	
		al_destroy_font(allegro_vars.font);
		al_destroy_display(allegro_vars.disp);
	}
	
	al_destroy_timer(allegro_vars.timer);
	al_destroy_event_queue(allegro_vars.queue);
}

void allegro_reinit_display(void)
{
	

	al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR | ALLEGRO_MAG_LINEAR);
	// Para tener aceleracion por HW desde la GPU (hace que no explote con los draw_text)
	al_set_new_bitmap_flags(ALLEGRO_VIDEO_BITMAP);
	// al_set_new_display_flags(ALLEGRO_RESIZABLE);

	// Titulo de la ventana
	al_set_new_window_title("~ Programación I ~ TP Final ~ Frogger ~");

	if(!window_x && !window_y)
		// Centrado en pantalla, según el monitor
		al_set_new_window_position(monitor_info.x2 / 2 - DISPLAY_W / 2, monitor_info.y2 / 2 - DISPLAY_H / 2 - 50);
	else
		al_set_new_window_position(window_x - 5, window_y - 29);

	// opciones para el display (antialiasing)
	al_set_new_display_option(ALLEGRO_SAMPLE_BUFFERS, 1, ALLEGRO_SUGGEST);
	al_set_new_display_option(ALLEGRO_SAMPLES, 8, ALLEGRO_SUGGEST);

	// creación del display
	allegro_vars.disp = al_create_display(DISPLAY_W, DISPLAY_H);
	must_init(allegro_vars.disp, "display");
	al_register_event_source(allegro_vars.queue, al_get_display_event_source(allegro_vars.disp));

	al_set_display_icon(allegro_vars.disp, sprites.icon);

	// Reload de la fuente
	char string[60] = PATH_FONTS;
	strcat(string, FONT_FILE_NAME);
	allegro_vars.font = al_load_font(string, FONT_HEIGHT, 0);
	must_init(allegro_vars.font, "font");
	allegro_vars.font_h = al_get_font_line_height(allegro_vars.font);
	allegro_vars.font_w = al_get_text_width(allegro_vars.font, "a");


	display_state = true;
}

void allegro_deinit_display(void)
{
	if (display_state)
	{
		al_get_window_position(allegro_vars.disp, &window_x, &window_y);

		al_destroy_font(allegro_vars.font);

		al_unregister_event_source(allegro_vars.queue, al_get_display_event_source(allegro_vars.disp));
		al_destroy_display(allegro_vars.disp);

		display_state = false;
	}
}

unsigned char allegro_get_last_key(void)
{
	return (last_key);
}

void allegro_set_last_key(unsigned char allegro_key_code)
{
	last_key = allegro_key_code;
}

ALLEGRO_EVENT_TYPE allegro_wait_for_event(void)
{
	al_wait_for_event(allegro_vars.queue, &allegro_vars.event);

	return (allegro_vars.event.type);
}

ALLEGRO_EVENT *allegro_get_next_event(void)
{
	bool flag = al_get_next_event(allegro_vars.queue, &allegro_vars.event);

	if (flag)
		return (&allegro_vars.event);
	else
		return NULL;
}

ALLEGRO_EVENT allegro_get_var_event(void)
{
	return (allegro_vars.event);
}

bool allegro_get_var_done(void)
{
	return (allegro_vars.done);
}

bool allegro_get_var_redraw(void)
{
	return (allegro_vars.redraw);
}

void allegro_set_var_done(bool state)
{
	allegro_vars.done = state;
}

void allegro_set_var_redraw(bool state)
{
	allegro_vars.redraw = state;
}

ALLEGRO_FONT *allegro_get_var_font(void)
{
	return (allegro_vars.font);
}

int allegro_get_var_font_h(void)
{
	return (allegro_vars.font_h);
}

int allegro_get_var_font_w(void)
{
	return (allegro_vars.font_w);
}

void allegro_clear_display(void)
{
	al_clear_to_color(al_map_rgb(0, 0, 0));
}

void allegro_draw_background(void)
{
	al_draw_bitmap(sprites.background, 0, 0, 0);
}

void allegro_draw_menu_background(int window)
{
	al_draw_bitmap(sprites.menu[window].background, 0, 0, 0);
}

bool allegro_is_event_queueVacia(void)
{
	return (al_is_event_queue_empty(allegro_vars.queue));
}

ALLEGRO_EVENT_QUEUE *allegro_get_event_queue(void)
{
	return (allegro_vars.queue);
}

void allegro_set_var_event(ALLEGRO_EVENT event)
{
	allegro_vars.event = event;
}

#pragma region allegro_sound

#pragma region allegro_sound_set_stream
void allegro_sound_set_stream_credits(void)
{
	char file[] = SOUND_STREAM_FILE_CREDITS;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "credits stream");
	}
}

void allegro_sound_set_stream_main_menu(void)
{
	char file[] = SOUND_STREAM_FILE_MAIN;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "main menu stream");
	}
}

void allegro_sound_set_stream_pause_menu(void)
{
	char file[] = SOUND_STREAM_FILE_PAUSE;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "pause menu stream");
	}
}

void allegro_sound_set_stream_ranking(void)
{
	char file[] = SOUND_STREAM_FILE_RANKING;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "ranking stream");
	}
}

void allegro_sound_set_stream_playing(void)
{
	char file[] = SOUND_STREAM_FILE_PLAYING;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "playing stream");
	}
}

void allegro_sound_set_stream_rick(void)
{
	char file[] = SOUND_STREAM_FILE_RICK;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "credtis stream");
	}
}

void allegro_sound_set_stream_game_over(void)
{
	char file[] = SOUND_STREAM_FILE_GAME_OVER;

	// si ya estaba inicializado...
	if (strcmp(file, last_init_stream) == 0)
	{
		allegro_sound_pause_stream();
	}
	else
	{
		must_init(init_audio_stream(file, stream_gain),
				  "game over stream");
	}
}

#pragma endregion allegro_sound_set_stream

#pragma region allegro_sound_control
void allegro_sound_toggle_stream(void)
{
	if (sounds.stream_state != SOUND_STREAM_STATE_NO_INIT)
	{
		bool state = al_get_audio_stream_playing(sounds.stream);

		must_init(al_set_audio_stream_playing(sounds.stream, !state),
				  "set to toggle stream");

		if (!state)
			sounds.stream_state = SOUND_STREAM_STATE_PAUSE;
		else
			sounds.stream_state = SOUND_STREAM_STATE_PLAY;
	}
}

void allegro_sound_play_stream(void)
{
	if (sounds.stream_state != SOUND_STREAM_STATE_NO_INIT)
	{
		al_set_audio_stream_playing(sounds.stream, true);
		sounds.stream_state = SOUND_STREAM_STATE_PLAY;
	}
}

void allegro_sound_pause_stream(void)
{
	if (sounds.stream_state != SOUND_STREAM_STATE_NO_INIT)
	{
		al_set_audio_stream_playing(sounds.stream, false);
		sounds.stream_state = SOUND_STREAM_STATE_PAUSE;
	}
}

void allegro_sound_restart_stream(void)
{
	if (sounds.stream_state != SOUND_STREAM_STATE_NO_INIT)
	{
		init_audio_stream(last_init_stream, stream_gain);
	}
}

void allegro_sound_set_stream_gain_up(void)
{
	if (stream_gain <= 0.9)
	{
		stream_gain += 0.1;
		last_stream_gain = stream_gain;
		al_set_audio_stream_gain(sounds.stream, stream_gain);
	}
}

void allegro_sound_set_stream_gain_down(void)
{
	if (stream_gain >= 0.1)
	{
		stream_gain -= 0.1;
		last_stream_gain = stream_gain;
		al_set_audio_stream_gain(sounds.stream, stream_gain);
	}
}

void allegro_sound_mute(void)
{
	last_stream_gain = stream_gain;
	stream_gain = 0;
	al_set_audio_stream_gain(sounds.stream, stream_gain);
}

void allegro_sound_unmute(void)
{
	stream_gain = last_stream_gain;
	al_set_audio_stream_gain(sounds.stream, stream_gain);
}

#pragma endregion allegro_sound_control

#pragma region allegro_sound_play_sample
void allegro_sound_play_effect_bonus(void)
{
	al_play_sample(sounds.samples.bonus, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_click(void)
{
	al_play_sample(sounds.samples.click, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_crash(void)
{
	al_play_sample(sounds.samples.crash, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_drowned(void)
{
	al_play_sample(sounds.samples.drowned, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_goal(void)
{
	al_play_sample(sounds.samples.goal, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_jump(void)
{
	al_play_sample(sounds.samples.jump, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_low_time(void)
{
	al_play_sample(sounds.samples.low_time, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_run_completed(void)
{
	al_play_sample(sounds.samples.run_completed, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_menu_enter(void)
{
	al_play_sample(sounds.samples.menu_enter, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_new_max_score(void)
{
	al_play_sample(sounds.samples.new_max_score, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_exiting(void)
{
	al_play_sample(sounds.samples.exiting, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_no_time(void)
{
	al_play_sample(sounds.samples.no_time, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

void allegro_sound_play_effect_coin_drop(void)
{
	al_play_sample(sounds.samples.coin_drop, stream_gain, 0.0, 1.0, ALLEGRO_PLAYMODE_ONCE, 0);
}

#pragma endregion allegro_sound_play_sample

#pragma endregion allegro_sound

void allegro_draw_hitbox(int x, int y, int w, int h)
{
	al_draw_rectangle(x,
					  y,
					  x + w,
					  y + h,
					  al_map_rgb(100, 100, 100),
					  1); // grosor
}

void allegro_rick_on(void)
{
	strcpy(rick_prev_stream, last_init_stream);

	allegro_sound_set_stream_rick();
	allegro_sound_play_stream();
}

bool allegro_get_rick_flag(void)
{
	return rick_flag;
}

void allegro_set_rick_flag(bool state)
{
	rick_flag = state;
}

void allegro_rick_off(void)
{
	must_init(init_audio_stream(rick_prev_stream, stream_gain),
			  "retornando stream ~~ sacando rick");
	allegro_sound_play_stream();
}

void allegro_rick_draw(void)
{
	al_draw_bitmap(algif_get_bitmap(rick, al_get_time()), 100, DISPLAY_H / 2, 0);
}

/*******************************************************************************
 *******************************************************************************
            LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

static ALLEGRO_BITMAP *sprite_cut(ALLEGRO_BITMAP *source_bmp, int x, int y, int w, int h)
{
	ALLEGRO_BITMAP *sprite = al_create_sub_bitmap(source_bmp, x, y, w, h);
	must_init(sprite, "sprite cut");
	return sprite;
}

static void sprites_init(void)
{
	int i, offset;
	pair_xy_t temp_xy;
	int temp_w, temp_h;

	char *path = NULL;

	// de la rana completo
	path = make_sprite_path(SPRITE_FROG, NULL);
	sprites.frog_uncut = al_load_bitmap(path);

	// se particiona el de la rana en sus 8 partes
	for (i = 0; i < FROG_FRAMES; i++)
	{
		temp_xy = getXYFromFrogFrame(i);

		if (!(i % 2)) // los sprites pares
		{
			temp_w = SPRITE_SIZE_FROG_STATIC_W;
			temp_h = SPRITE_SIZE_FROG_STATIC_H;
		}
		else if (i == 1 || i == 7)
		{
			temp_w = SPRITE_SIZE_FROG_DYNAMIC_SHORT;
			temp_h = SPRITE_SIZE_FROG_DYNAMIC_LONG;
		}
		else
		{
			temp_w = SPRITE_SIZE_FROG_DYNAMIC_LONG;
			temp_h = SPRITE_SIZE_FROG_DYNAMIC_SHORT;
		}

		sprites.frog[i] = sprite_cut(sprites.frog_uncut, temp_xy.x, temp_xy.y, temp_w, temp_h);
	}

	// el del fondo
	path = make_sprite_path(SPRITE_BACKGROUND, path);
	sprites.background = al_load_bitmap(path);

	// el de los troncos
	path = make_sprite_path(SPRITE_LOG, path);
	sprites.log = al_load_bitmap(path);

	// recorte de los autos.

	path = make_sprite_path(SPRITE_CAR, path);
	sprites.cars_uncut = al_load_bitmap(path);

	sprites.car[0] = sprite_cut(sprites.cars_uncut, getXYFromCarFrame(0).x, getXYFromCarFrame(0).y, CAR_W, CAR_H);
	sprites.car[1] = sprite_cut(sprites.cars_uncut, getXYFromCarFrame(1).x, getXYFromCarFrame(1).y, CAR_W, CAR_H);
	sprites.car[2] = sprite_cut(sprites.cars_uncut, getXYFromCarFrame(2).x, getXYFromCarFrame(2).y, CAR_W, CAR_H);
	sprites.car[3] = sprite_cut(sprites.cars_uncut, getXYFromCarFrame(3).x, getXYFromCarFrame(3).y, CAR_TRUCK_FIRE_W, CAR_H);
	sprites.car[4] = sprite_cut(sprites.cars_uncut, getXYFromCarFrame(4).x, getXYFromCarFrame(4).y, CAR_TRUCK_W, CAR_H);

	// el de las tortugas sin recortar
	path = make_sprite_path(SPRITE_TURTLES, path);
	sprites.turtle_uncut = al_load_bitmap(path);

	// se recortan los de la tortuga en sus 11 partes
	for (i = 0; i < TURTLE_FRAMES; i++)
	{
		temp_xy = getXYFromTurtleFrame(i);

		sprites.turtle[i] = sprite_cut(sprites.turtle_uncut, temp_xy.x, temp_xy.y, TURTLE_SIDE, TURTLE_SIDE);
	}

	// corazon
	path = make_sprite_path(SPRITE_HEART, path);
	sprites.heart = al_load_bitmap(path);

	// fondo de menu
	path = make_sprite_path(SPRITE_MENU_HOME_BACK, path);
	sprites.menu[MENU_WINDOW_HOME].background = al_load_bitmap(path);

	// botones con highlight, sin recortar
	path = make_sprite_path(SPRITE_MENU_HOME, path);
	sprites.menu[MENU_WINDOW_HOME].uncut = al_load_bitmap(path);

	// se recortan los highlight
	for (i = 0, offset = 0; i < MENU_STATE_MAX; i++, offset += MENU_OPTION_DELTA_Y)
	{
		sprites.menu[MENU_WINDOW_HOME].option[i] = sprite_cut(sprites.menu[MENU_WINDOW_HOME].uncut,
															  MENU_OPTION_TOPLEFT_X,
															  MENU_OPTION_TOPLEFT_Y + offset,
															  MENU_OPTION_W,
															  MENU_OPTION_H);
	}

	path = make_sprite_path(SPRITE_MENU_DIFF_BACK, path);
	sprites.menu[MENU_WINDOW_DIFFICULTY].background = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_MENU_DIFF, path);
	sprites.menu[MENU_WINDOW_DIFFICULTY].uncut = al_load_bitmap(path);

	for (i = 0, offset = 0; i < MENU_STATE_MAX; i++, offset += MENU_OPTION_DELTA_Y)
	{
		sprites.menu[MENU_WINDOW_DIFFICULTY].option[i] = sprite_cut(sprites.menu[MENU_WINDOW_DIFFICULTY].uncut,
																	MENU_OPTION_TOPLEFT_X,
																	MENU_OPTION_TOPLEFT_Y + offset,
																	MENU_OPTION_W,
																	MENU_OPTION_H);
	}

	path = make_sprite_path(SPRITE_MENU_PAUSE_BACK, path);
	sprites.menu[MENU_WINDOW_PAUSE].background = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_MENU_PAUSE, path);
	sprites.menu[MENU_WINDOW_PAUSE].uncut = al_load_bitmap(path);

	for (i = 0, offset = 0; i < MENU_STATE_MAX; i++, offset += MENU_OPTION_DELTA_Y)
	{
		sprites.menu[MENU_WINDOW_PAUSE].option[i] = sprite_cut(sprites.menu[MENU_WINDOW_PAUSE].uncut,
															   MENU_OPTION_TOPLEFT_X,
															   MENU_OPTION_TOPLEFT_Y + offset,
															   MENU_OPTION_W,
															   MENU_OPTION_H);
	}

	path = make_sprite_path(SPRITE_MENU_GAME_OVER_BACK, path);
	sprites.menu[MENU_WINDOW_GAME_OVER].background = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_MENU_GAME_OVER, path);
	sprites.menu[MENU_WINDOW_GAME_OVER].uncut = al_load_bitmap(path);

	for (i = 0, offset = 0; i < MENU_STATE_MAX; i++, offset += MENU_OPTION_DELTA_Y)
	{
		sprites.menu[MENU_WINDOW_GAME_OVER].option[i] = sprite_cut(sprites.menu[MENU_WINDOW_GAME_OVER].uncut,
																   MENU_OPTION_TOPLEFT_X,
																   MENU_OPTION_TOPLEFT_Y + offset,
																   MENU_OPTION_W,
																   MENU_OPTION_H);
	}

	path = make_sprite_path(SPRITE_CREDITS, path);
	sprites.credits = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_NAME, path);
	sprites.name = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_TUTORIAL, path);
	sprites.tutorial = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_ICON, path);
	sprites.icon = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_DEAD, path);
	sprites.dead = al_load_bitmap(path);

	path = make_sprite_path(SPRITE_COIN, path);
	sprites.coin.uncut = al_load_bitmap(path);
	for (i = 0; i < SPRITE_COIN_FRAMES; i++)
	{
		pair_xy_t coord = getXYFromCoinFrame(i);
		sprites.coin.frame[i] = sprite_cut(sprites.coin.uncut, coord.x, coord.y, SPRITE_COIN_SIDE, SPRITE_COIN_SIDE);
	}

	path = make_sprite_path(SPRITE_SPLASH, path);
	sprites.splash.uncut = al_load_bitmap(path);
	for (i = 0; i < SPRITE_SPLASH_FRAMES; i++)
	{
		pair_xy_t coord = getXYFromSplashFrame(i);
		sprites.splash.frame[i] = sprite_cut(sprites.splash.uncut, coord.x, coord.y, SPRITE_SPLASH_W, SPRITE_SPLASH_H);
	}

	path = make_sprite_path(SPRITE_BORDER, path);
	sprites.border = al_load_bitmap(path);

	free(path);
}

static char *make_sprite_path(char *file_name, char *prev_str)
{
	if (prev_str != NULL)
		free(prev_str);

	char *path = NULL;

	int str_size = sizeof(PATH_SPRITES) + strlen(file_name) + sizeof(EXTENSION_SPRITES) + 1;

	path = malloc(str_size);
	must_init(path, file_name);

	memset(path, 0, str_size);

	strcat(path, PATH_SPRITES);
	strcat(path, file_name);
	strcat(path, EXTENSION_SPRITES);

	return path;
}

static void sprites_deinit(void)
{
	int i, j;

	al_destroy_bitmap(sprites.frog_uncut);

	for (i = 0; i < FROG_FRAMES; i++)
		al_destroy_bitmap(sprites.frog[i]);

	al_destroy_bitmap(sprites.background);

	al_destroy_bitmap(sprites.log);

	for (i = 0; i < CAR_TYPE_N; i++)
		al_destroy_bitmap(sprites.car[i]);

	al_destroy_bitmap(sprites.turtle_uncut);

	for (i = 0; i < TURTLE_FRAMES; i++)
		al_destroy_bitmap(sprites.turtle[i]);

	al_destroy_bitmap(sprites.heart);

	for (i = 0; i < MENU_WINDOW_MAX; i++)
	{
		al_destroy_bitmap(sprites.menu[i].background);
		al_destroy_bitmap(sprites.menu[i].uncut);

		for (j = 0; j < MENU_STATE_MAX; j++)
		{
			al_destroy_bitmap(sprites.menu[i].option[j]);
		}
	}

	al_destroy_bitmap(sprites.credits);

	al_destroy_bitmap(sprites.name);

	al_destroy_bitmap(sprites.tutorial);

	al_destroy_bitmap(sprites.icon);

	al_destroy_bitmap(sprites.dead);

	al_destroy_bitmap(sprites.coin.uncut);
	for (i = 0; i < SPRITE_COIN_FRAMES; i++)
		al_destroy_bitmap(sprites.coin.frame[i]);

	al_destroy_bitmap(sprites.splash.uncut);
	for (i = 0; i < SPRITE_SPLASH_FRAMES; i++)
		al_destroy_bitmap(sprites.splash.frame[i]);

	al_destroy_bitmap(sprites.border);
}

static void audio_init(void)
{
	// streams
	sounds.stream_state = SOUND_STREAM_STATE_NO_INIT;

	// efectos de sonido
	must_init(init_sample(&sounds.samples.bonus, "bonus_alert"),
			  "effect_bonus sample");

	must_init(init_sample(&sounds.samples.click, "click"),
			  "effect_click sample");

	must_init(init_sample(&sounds.samples.crash, "crash"),
			  "effect_crash sample");

	must_init(init_sample(&sounds.samples.drowned, "fall_in_water"),
			  "effect_drowned sample");

	must_init(init_sample(&sounds.samples.goal, "goal_reached"),
			  "effect_goal sample");

	must_init(init_sample(&sounds.samples.jump, "jump_original"),
			  "effect_jump sample");

	must_init(init_sample(&sounds.samples.low_time, "low_time_PC"),
			  "effect_low_time sample");

	must_init(init_sample(&sounds.samples.run_completed, "run_completed"),
			  "effect_run_completed sample");

	must_init(init_sample(&sounds.samples.menu_enter, "menu_enter"),
			  "effect_menu_enter sample");

	must_init(init_sample(&sounds.samples.new_max_score, "new_max_score"),
			  "effect_new_max_score sample");

	must_init(init_sample(&sounds.samples.exiting, "saliendo"),
			  "effect_saliendo sample");

	must_init(init_sample(&sounds.samples.no_time, "no_time"),
			  "effect_no_time sample");

	must_init(init_sample(&sounds.samples.coin_drop, "coin_drop"),
			  "effect_coin_drop sample");
}

static void audio_deinit(void)
{
	if (sounds.stream_state != SOUND_STREAM_STATE_NO_INIT)
		al_destroy_audio_stream(sounds.stream);

	al_destroy_sample(sounds.samples.bonus);
	al_destroy_sample(sounds.samples.click);
	al_destroy_sample(sounds.samples.crash);
	al_destroy_sample(sounds.samples.drowned);
	al_destroy_sample(sounds.samples.goal);
	al_destroy_sample(sounds.samples.jump);
	al_destroy_sample(sounds.samples.low_time);
	al_destroy_sample(sounds.samples.run_completed);
	al_destroy_sample(sounds.samples.menu_enter);
	al_destroy_sample(sounds.samples.no_time);
	al_destroy_sample(sounds.samples.coin_drop);
}

static bool init_audio_stream(const char *file, float gain)
{
	if (file == NULL)
		return false;

	ALLEGRO_AUDIO_STREAM **pt = &sounds.stream;
	unsigned char *state = &sounds.stream_state;

	int str_size = sizeof(PATH_SOUND_STREAMS) + strlen(file) + sizeof(EXTENSION_SOUND_STREAM) + 1;
	char *path = NULL;

	// analisis de reproduccion y carga de stream "para que no explote todo"
	switch (*state)
	{
	case SOUND_STREAM_STATE_PLAY:
		// pausa
		al_set_audio_stream_playing(*pt, false);

	case SOUND_STREAM_STATE_PAUSE:
		// desacople del mixer
		al_detach_audio_stream(*pt);
		// destruccion
		al_destroy_audio_stream(*pt);

	case SOUND_STREAM_STATE_NO_INIT:
		// armado del path del archivo
		path = malloc(str_size);
		must_init(path, file);
		memset(path, 0, str_size);
		strcat(path, PATH_SOUND_STREAMS);
		strcat(path, file);
		strcat(path, EXTENSION_SOUND_STREAM);

		// carga del stream
		*pt = al_load_audio_stream(path, 2, 2048);
		if (*pt == NULL)
			return false;

		free(path);

		// modo de reproduccion
		al_set_audio_stream_playmode(*pt, ALLEGRO_PLAYMODE_LOOP);

		// ganancia
		al_set_audio_stream_gain(*pt, gain);

		// pausa
		al_set_audio_stream_playing(*pt, false);

		//"para que suene" (acople al mixer)
		al_attach_audio_stream_to_mixer(sounds.stream, al_get_default_mixer());

		// actualiza el nombre del ultimo stream inicializado
		strcpy(last_init_stream, file);

		*state = SOUND_STREAM_STATE_PAUSE;
		break;

	default:
		break;
	}

	return true;
}

static bool init_sample(ALLEGRO_SAMPLE **sample, const char *file)
{
	if (file == NULL)
		return false;

	int str_size = sizeof(PATH_SOUND_SAMPLES) + strlen(file) + sizeof(EXTENSION_SOUND_SAMPLE) + 1;
	char *path = NULL;

	path = malloc(str_size);
	must_init(path, file);
	memset(path, 0, str_size);
	strcat(path, PATH_SOUND_SAMPLES);
	strcat(path, file);
	strcat(path, EXTENSION_SOUND_SAMPLE);

	*sample = al_load_sample(path);

	free(path);

	if (*sample == NULL)
		return false;

	return true;
}

static void rick_init(void)
{
	rick = algif_load_animation("../res/gifs/rick.gif");
	allegro_set_rick_flag(false);
}

static void rick_deinit()
{
	algif_destroy_animation(rick);
}

/**
 * @file 	entities.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo entities. Se encarga de la creacion, actualización
 * 			y muestreo de las entitades implementadas en PC.
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "entities.h"
#include "allegro_stuff.h"
#include "geometry.h"
#include "game_data.h"

/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

//#define DEBUG_ENTITIES_TEXT

#define LOGS_SPAWN_MIN 1
#define LOGS_SPAWN_MAX 3
#define LOGS_SPAWN_FRAMES 60
#define LOGS_BASE_SPEED 1
#define LOGS_MAX_USED 8
#define LOGS_EXTRA_SEPARATOR LOG_W / 2

#define CARS_SPAWN_MIN 2
#define CARS_SPAWN_FRAMES 60
#define CARS_BASE_SPEED 1
#define CARS_MAX_USED 15
#define CAR_SPEED_INCREASE 2
#define CAR_WAIT_INCREASE 1
#define CARS_EXTRA_SEPARATOR CAR_W * 2
#define CAR_SP_CH_WAIT FPS // frames para cambiar dfe velocidad

#define TURTLES_MIN_PER_PACK 1
#define TURTLES_MAX_PER_PACK 3
#define TURTLES_SPAWN_FRAMES 60 // cada cuantos frames spawnean
#define TURTLES_SPAWN_MIN 1		// minimas a spawnear de una
#define TURTLES_SPAWN_MAX 3		// maximas a spawnear de una
#define TURTLES_MAX_USED 8		// maximas en pantalla
#define TURTLES_BASE_SPEED 2
#define TURTLES_FRAME_TIMEOUT_SURFACE 10	// cuanto "tiempo" dura un frame dibujado antes de pasar al siguiente
#define TURTLES_FRAME_TIMEOUT_GOING_DOWN 50 // tiempo por frame al sumergirse
#define TURTLES_FRAME_TIMEOUT_WATER 20		// tiempo por frame para mostrarse bajo el agua
#define TURTLES_FRAME_TIMEOUT_GOING_UP 10	// tiempo por frame para mostrarse saliendo del agua
#define TURTLES_SURFACE_FRAMES_MIN 60		// minimo "tiempo" en superficie
#define TURTLES_SURFACE_FRAMES_MAX 600		// maximo "tiempo" en superficie
#define TURTLES_WATER_FRAMES_MIN 60			// minimo "tiempo" bajo el agua
#define TURTLES_WATER_FRAMES_MAX 200		// maximo "tiempo" bajo el agua
#define TURTLES_EXTRA_SEPARATOR TURTLE_SIDE * 2

#define COIN_SPAWN_FRAMES_MIN 300	// mínimo tiempo para respawnear coin
#define COIN_SPAWN_FRAMES_MAX 600	// maximo tiempo para respawnear coin
#define COIN_DESPAWN_FRAMES_MIN 700 // mínimo tiempo para sacar coin
#define COIN_DESPAWN_FRAMES_MAX 900 // maximo tiempo para sacar coin
#define COIN_FRAME_RATE 10			// cada cuanto gira la coin
#define COIN_FRAMES_TO_WARN_A 250	// frames previos al despawneo cuando empieza a titilar
#define COIN_FRAMES_TO_WARN_B 100
#define COIN_WARNING_FRAMES_A 20 // blink rate
#define COIN_WARNING_FRAMES_B 10

#define SPRITE_DEAD_TIMEOUT 80 // frames que permanece en pantalla el sprite de muerte

#define SPRITE_SPLASH_RATE 10 // cada cuanto avanza un frame la animacion

/*******************************************************************************
 * ENUMERATIONS AND STRUCTURES AND TYPEDEFS
 ******************************************************************************/

typedef struct
{
	int x;
	int y;
	int moving;
	int facing;
	int steps;
	unsigned char state;
	unsigned char next_action;

} frog_t;

typedef struct
{
	int x; // Posicion del auto
	int y;
	int lane;	   // Carril del auto.
	int dx;		   // Velocidad del auto.
	CAR_TYPE type; // Tipo de auto.
	int length;	   // Largo del auto.
	int count;
	bool fast;
	bool used; // Marca disponibilidad en el array.
} car_t;

typedef struct
{
	int x;
	int y;
	int lane;
	int dx;
	bool used;

} log_t;

typedef struct
{
	int x;						   // coordenada x
	int y;						   // coordenada y
	int lane;					   // carril
	int dx;						   // velocidad
	bool used;					   // flag de usada o no
	unsigned char turtles_in_pack; // cantidad de tortugas en el paquete

	struct
	{
		unsigned char frame;  // contador que indica en qué frame de la animación se está (de 1 a TURTLES_FRAMES)
		unsigned int timeout; // timeout interno para cambiar de frame
		unsigned int cont;	  // contador interno de frames de juego ejecutados
	} fx;

	int wide;			 // ancho del paquete, proporcional a turtles_in_pack y a TURTLES_SIDE
	unsigned char state; // estado (enum TURTLE_STATES)
} turtle_pack_t;

typedef struct
{
	int x;
	int y;
	bool used; // flag de usada o no
	struct
	{
		unsigned int frame_cont;  // contador de frame a mostrar
		unsigned int timeout;	  // Para spawneo y despawneo
		unsigned int blink_timer; // Para titilar coin antes de sacarla
		unsigned int cont;		  // contador interno de frames de juego ejecutados
		bool flag;				  // Para indicar si debe parpadear o no
	} fx;

} coin_t;

enum TURTLE_STATES
{
	TURTLE_STATE_SURFACE,
	TURTLE_STATE_GOING_DOWN,
	TURTLE_STATE_WATER,
	TURTLE_STATE_GOING_UP
};

enum FROG_STATES
{
	FROG_STATE_ROAD,
	FROG_STATE_WATER,
	FROG_STATE_LOG,
	FROG_STATE_TURTLE,
	FROG_STATE_GOAL,
	FROG_STATE_GOAL_COIN, // meta con coin
	FROG_STATE_CRASH_CAR,
	FROG_STATE_CRASH_WALL,
	FROG_STATE_BOUNCING_WALL // rebota contra algun borde
};

// Estructur para administrar el sprite de muerte
static struct
{
	bool flag;			// para indicar graficar
	unsigned int timer; // contador para permanecer en pantalla
	unsigned int x;
	unsigned int y;
} corpse_fx;

// Estructura para administrar el efecto de caida en agua
static struct
{
	bool flag;				 // usado o no
	unsigned int frame_cont; // contador de frame a mostrar
	unsigned int cont;		 // contador de ejecucion
	unsigned int x;			 // X topleft
	unsigned int y;			 // Y topleft

} splash_fx;

/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/**
 * @brief Inicializa la rana
 *
 */
static void frog_init(void);

/**
 * @brief Actualiza posicionamiento de la rana
 *
 */
static void frog_update(void);

/**
 * @brief Dibuja la rana
 *
 */
static void frog_draw(void);

/**
 * @brief Inicializa troncos
 *
 */
static void logs_init(void);

/**
 * @brief Actualiza troncos
 *
 */
static void logs_update(void);

/**
 * @brief Dibuja troncos
 *
 */
static void logs_draw(void);

/**
 * @brief Inicializa autos
 *
 */
static void cars_init(void);

/**
 * @brief Actualiza autos
 *
 */
static void cars_update(void);

/**
 * @brief Dibuja autos
 *
 */
static void cars_draw(void);

/**
 * @brief Inicializacion de tortugas
 *
 */
static void turtles_init(void);

/**
 * @brief Actualizacion de tortugas
 *
 */
static void turtles_update(void);

/**
 * @brief Dibujo de tortugas
 *
 */
static void turtles_draw(void);

/**
 * @brief Inicializacion de coin
 *
 */
static void coin_init(void);

/**
 * @brief Actualizacion de coin
 *
 */
static void coin_update(void);

/**
 * @brief Dibujo de coin
 *
 */
static void coin_draw(void);

/**
 * @brief Alinea y centra la posición de la rana con las celdas del mapa, por desvios sobre troncos.
 *
 */
// static void fix_frog_pos(void);

/**
 * @brief Alinea coordenadaY de la rana con las celdas del mapa, por desvios varios.
 *
 */
static void fix_frog_coord_y(void);

/**
 * @brief Verifica si la rana llego a un punto de llegada valido
 *
 * Verifica en terminos de coordenada X y en terminos de si el punto de llegada es repetido
 *
 * @return true Llegó
 * @return false No llegó
 */
static bool is_frog_in_goal(void);

/**
 * @brief Configura sprite de muerte para que se muestre
 *
 * @param x Coordenada topleft X de rana
 * @param y Coordenada topleft Y de rana
 */
static void corpse_init(int x, int y);

/**
 * @brief Updates para sacar el sprite de muerte
 *
 */
static void corpse_update(void);

/**
 * @brief Dibuja el sprite de muerte
 *
 */
static void corpse_draw(void);

/**
 * @brief Configura sprites de splash para que se muestre
 *
 * @param x Coordenada topleft X de rana
 * @param y Coordenada topleft Y de rana
 */
static void splash_init(int x, int y);

/**
 * @brief Actualiza los frames del splash
 *
 */
static void splash_update(void);

/**
 * @brief Dibuja el splash
 *
 */
static void splash_draw(void);

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

// Rana
static frog_t frog;

// Array de troncos
static log_t log[LOGS_MAX_USED];

// Array de autos
static car_t car[CARS_MAX_USED];

// Array de paquetes de tortugas
static turtle_pack_t turtle_pack[TURTLES_MAX_USED];

// Coin
static coin_t coin;

// Contador de frames ejecutados
static unsigned long game_frames;

// Carriles variables.
static unsigned char normal_diff_lane;
static unsigned char hard_diff_lane_1;
static unsigned char hard_diff_lane_2;

// Maximo de autos spawneados.

static unsigned char cars_spawn_max;

// Flag muestra tutorial

static bool tutorial_flag;
/*******************************************************************************
 *******************************************************************************
            GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void entities_init(void)
{
	tutorial_flag = false;
	frog_init();
	logs_init();
	cars_init();
	turtles_init();
	coin_init();

	game_frames = 0;

	corpse_fx.flag = false;

	splash_fx.flag = false;
}

void entities_update()
{
	game_frames = game_data_get_frames();
	
	frog_update();
	logs_update();
	cars_update();
	turtles_update();
	coin_update();

	corpse_update();
	splash_update();
}

void entities_draw()
{
	logs_draw();
	cars_draw();
	turtles_draw();
	coin_draw();

	splash_draw();
	corpse_draw();

	//"frog siempre a lo ultimo, para que se vea"
	frog_draw();
}

void entities_move_frog(unsigned char direction)
{
	if(tutorial_flag){
		if (direction == DIRECTION_DOWN || direction == DIRECTION_LEFT ||
			direction == DIRECTION_UP || direction == DIRECTION_RIGHT)
		{
			frog.next_action = direction;
		}
	}
}

void entities_set_tutorial(void){
	tutorial_flag = true;
}

bool entities_get_tutorial(void){
	return tutorial_flag;
}


/*******************************************************************************
 *******************************************************************************
            LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

static void frog_init(void)
{
	frog.x = CELL_START_FROG_X;
	frog.y = CELL_START_FROG_Y;
	frog.moving = false;
	frog.facing = DIRECTION_UP;
	frog.steps = 0;
	frog.state = FROG_STATE_ROAD;
	frog.next_action = DIRECTION_NONE;
}

static void frog_update(void)
{
	int i;

	bool interaction_flag = false;

	if(!frog.moving)
	{
		if(frog.next_action == DIRECTION_DOWN || frog.next_action == DIRECTION_LEFT ||
			frog.next_action == DIRECTION_UP || frog.next_action == DIRECTION_RIGHT)
		{
			frog.facing = frog.next_action;
			frog.moving = true;
			frog.next_action = DIRECTION_NONE;
			allegro_sound_play_effect_jump();
		}

	}

	else if (frog.moving)
	{

		if(frog.facing == DIRECTION_LEFT)
			frog.x -= STEP_FRACTION_SIZE;
		else if(frog.facing == DIRECTION_RIGHT)
			frog.x += STEP_FRACTION_SIZE;
		else if(frog.facing == DIRECTION_UP)
			frog.y -= STEP_FRACTION_SIZE;
		else if(frog.facing == DIRECTION_DOWN)
			frog.y += STEP_FRACTION_SIZE;

		if(++frog.steps >= STEP_RATIO)
		{
			frog.steps = 0;
			frog.moving = false;

			fix_frog_coord_y();
		}
	}


	//donde esta parada
	if(!frog.moving)
	{
		unsigned int y_no_offset = frog.y - FROG_OFFSET_Y;

		//en alguna fila de descanso o de autos
		if(y_no_offset >= CELL_H * (lanes_cars[0] - 1) && y_no_offset <= DISPLAY_H - CELL_H)
			frog.state = FROG_STATE_ROAD;

		//en alguna fila de agua. Luego se actualiza si es sobre tronco o turtle
		else if(y_no_offset >= CELL_H * 2 && y_no_offset <= CELL_H * (lanes_cars[0] - 1))
			frog.state = FROG_STATE_WATER;

		//choque contra alguno de los muros superiores, o llegada bien a un goal
		else if (y_no_offset < CELL_H * 2)
		{
			if(!is_frog_in_goal())
			{
				frog.state = FROG_STATE_CRASH_WALL;
			}

			else
			{
				frog.state = FROG_STATE_GOAL;

				//colision con coin
				if(coin.used)
				{
					if(collideShort(	coin.x,
										coin.y,
										SPRITE_COIN_SIDE,
										SPRITE_COIN_SIDE,
										frog.x,
										frog.y,
										FROG_W,
										FROG_H))
					{
						frog.state = FROG_STATE_GOAL_COIN;
						coin.used = false;
					}
				}

				
			}

			interaction_flag = true;
		}

		if(!interaction_flag)
		{
			//colision con autos
			for(i = 0; i < CARS_MAX_USED; i++)
			{
				if(!car[i].used)
					continue;
				
				if(collideShort(	car[i].x,
									car[i].y,
									car[i].length,
									CAR_H,
									frog.x,
									frog.y,
									FROG_W,
									FROG_H))
				{
					frog.state = FROG_STATE_CRASH_CAR;
					interaction_flag = true;
					break;	//no puede chocar con 2 autos a la vez
				}
			}
		}
			
	}

	if(!interaction_flag)
	{
		//esta en algun tronco?
		for(i = 0; i < LOGS_MAX_USED; i++)
		{
			if(!log[i].used)
				continue;

			if(insideShortScaled(	log[i].x,
									log[i].y,
									LOG_W,
									LOG_H,
									frog.x,
									frog.y,
									FROG_W,
									FROG_H,
									INSERTION_FACTOR))
			{
				frog.x += log[i].dx;
				frog.state = FROG_STATE_LOG;
				interaction_flag = true;
				break;		//no puede estar en 2 troncos a la vez
			}
		}
	}
	
	if(!interaction_flag)
	{
		//esta en algun turtle_pack?
		for(i = 0; i < TURTLES_MAX_USED; i++)
		{
			//Omite si el pack no esta usado o si esta bajo agua
			if(!turtle_pack[i].used || turtle_pack[i].state == TURTLE_STATE_WATER)
				continue;

			if(insideShortScaled(	turtle_pack[i].x,
									turtle_pack[i].y,
									turtle_pack[i].wide,
									TURTLE_SIDE,
									frog.x,
									frog.y,
									FROG_W,
									FROG_H,
									INSERTION_FACTOR))
			{
				frog.x += turtle_pack[i].dx;
				frog.state = FROG_STATE_TURTLE;
				interaction_flag = true;
				break;		//no puede estar en 2 packs a la vez
			}
		}
	}
	

	//revision de limites
	if(frog.x < FROG_MIN_X)
		frog.x = FROG_MIN_X;
	else if(frog.x > FROG_MAX_X)
		frog.x = FROG_MAX_X;
	else if(frog.y < FROG_MIN_Y)
		frog.y = FROG_MIN_Y;
	else if(frog.y > FROG_MAX_Y)
		frog.y = FROG_MAX_Y;

	switch (frog.state)
	{
		case FROG_STATE_WATER:
			game_data_subtract_live();
			allegro_sound_play_effect_drowned();

			splash_init(frog.x, frog.y);

			frog_init();
			
			
			break;
		
		case FROG_STATE_CRASH_CAR:
			game_data_subtract_live();
			allegro_sound_play_effect_crash();

			corpse_init(frog.x, frog.y);

			frog_init();

			break;
		
		case FROG_STATE_CRASH_WALL:
			game_data_subtract_live();
			allegro_sound_play_effect_crash();

			corpse_init(frog.x, frog.y);

			frog_init();

			break;
		
		case FROG_STATE_GOAL:
			game_data_add_run_time_goal();
			game_data_add_score();
			allegro_sound_play_effect_goal();
			
			frog_init();
			
			break;
			
		case FROG_STATE_GOAL_COIN:
			game_data_add_run_time_goal_bonus();
			game_data_add_score_bonus();
			allegro_sound_play_effect_bonus();

			frog_init();

			break;
		
		default:
			break;
	}

#ifdef DEBUG_ENTITIES_TEXT
	if(!(game_frames % 10))
		printf("state: %d ~~ y_no_offset: %d\n", frog.state, frog.y - FROG_OFFSET_Y);
#endif

}

static void frog_draw(void)
{

	ALLEGRO_BITMAP *tempbitmap = NULL;

	if (frog.moving)
	{
		if (frog.facing == DIRECTION_UP)
			tempbitmap = sprites.frog[1];
		if (frog.facing == DIRECTION_DOWN)
			tempbitmap = sprites.frog[7];
		if (frog.facing == DIRECTION_RIGHT)
			tempbitmap = sprites.frog[3];
		if (frog.facing == DIRECTION_LEFT)
			tempbitmap = sprites.frog[5];
	}

	else if (!frog.moving)
	{
		if (frog.facing == DIRECTION_UP)
			tempbitmap = sprites.frog[0];
		if (frog.facing == DIRECTION_DOWN)
			tempbitmap = sprites.frog[6];
		if (frog.facing == DIRECTION_RIGHT)
			tempbitmap = sprites.frog[2];
		if (frog.facing == DIRECTION_LEFT)
			tempbitmap = sprites.frog[4];
	}

	al_draw_bitmap(tempbitmap, frog.x, frog.y, 0);

#ifdef DEBUG_ENTITIES_TEXT
	// hitbox
	allegro_draw_hitbox(frog.x, frog.y, FROG_W, FROG_H);
	// coordenadas rana
	al_draw_textf(allegro_get_var_font(), al_map_rgb(200, 50, 50), 0, 0, 0, "X: %d Y: %d", frog.x, frog.y);
#endif
}

static void logs_init(void)
{
	int i;
	for (i = 0; i < LOGS_MAX_USED; i++)
		log[i].used = false;
}

static void logs_update(void)
{
	// se busca spawnear entre LOGS_SPAWN_MIN y LOGS_SPAWN_MAX autos cada LOGS_SPAWN_FRAMES frames
	int new_quota = ((game_frames % LOGS_SPAWN_FRAMES) ? 0 : get_rand_between(LOGS_SPAWN_MIN, LOGS_SPAWN_MAX));

	int i, used;

	// cuento cuantos troncos usados hay
	for (i = 0, used = 0; i < LOGS_MAX_USED; i++)
		used += log[i].used;

	for (i = 0; i < LOGS_MAX_USED; i++)
	{
		// Spawneo de troncos
		if (!log[i].used && new_quota > 0 && used < LOGS_MAX_USED) // Lugar libre?
		{

			// Asigno carril.
			int temp_rand_log_lane = get_rand_between(0, LANES_LOG_TOTAL - 1);
			log[i].lane = lanes_logs[temp_rand_log_lane];

			// Coordenada 'y' en funcion del carril
			log[i].y = CELL_H * log[i].lane + LOG_OFFSET_Y;

			// Velocidad
			// log[i].dx = lanes_logs[LANES_LOG_TOTAL-1] - log[i].lane + 1;
			// log[i].dx = map_int(log[i].lane, 0, lanes_logs[LANES_LOG_TOTAL-1], 1, 3);
			log[i].dx = log[i].lane - (temp_rand_log_lane + 2) + LOGS_BASE_SPEED;

			// en pares...
			if (!(log[i].lane % 2))
			{
				// coordenada de inicio
				log[i].x = -LOG_W;
			}

			// en impares...
			else
			{
				// coordenada de inicio
				log[i].x = DISPLAY_W;

				// hacia el otro lado
				log[i].dx *= (-1);
			}

			int p;
			bool check; // para confirmar asignacion de lane
			for (p = 0, check = true; p < LOGS_MAX_USED; p++)
			{
				// si no es el mismo tronco, y ese otro esta usado, y coinciden en lane...
				if (p != i && log[p].used && log[p].lane == log[i].lane)
				{
					// si colisiona con algun otro tronco...
					if (collide(
							log[i].x - LOGS_EXTRA_SEPARATOR,
							log[i].y,
							log[i].x + LOG_W + LOGS_EXTRA_SEPARATOR,
							log[i].y + LOG_H,
							log[p].x,
							log[p].y,
							log[p].x + LOG_W,
							log[p].y + LOG_H))
					{
						// no spawnea
						check = false;
						break;
					}
				}
			}

			// si se puede spawnear...
			if (check)
			{
				// Pasa a usado
				log[i].used = true;
				used++;
				new_quota--;
			}

			// si no se puede spawnear...
			else
			{
			}
		}

		// si el tronco esta usado...
		else if (log[i].used)
		{
			// desplaza
			log[i].x += log[i].dx;

			// chequea si llego a los limites
			if ((log[i].dx > 0 && log[i].x >= DISPLAY_W) || (log[i].dx < 0 && log[i].x <= -LOG_W))
			{
				log[i].used = false;
				used--;
			}

			// printf("~log%d lane%d dx%d~\n", i, log[i].lane, log[i].dx);
		}
	}
}

static void logs_draw(void)
{
	int i;

	for (i = 0; i < LOGS_MAX_USED; i++)
	{
		if (log[i].used)
		{
			al_draw_bitmap(sprites.log, log[i].x, log[i].y, 0);

#ifdef DEBUG_ENTITIES_TEXT
			// hitbox
			allegro_draw_hitbox(log[i].x, log[i].y, LOG_W, LOG_H);
#endif
		}
	}

#ifdef DEBUG_ENTITIES_TEXT
	// coordenadas
	int space;
	for (i = 0, space = 20; i < LOGS_MAX_USED; i++, space += 10)
	{
		al_draw_textf(allegro_get_var_font(), al_map_rgb(200, 50, 50), 0, space, 0, "N°:%d X:%d Y:%d", i, log[i].x, log[i].y);
	}
#endif
}

static void cars_init(void)
{
	int i;
	// Inicio array de autos desocupando.
	for (i = 0; i < CARS_MAX_USED; i++)
		car[i].used = false;

	switch (game_data_get_diff())
	{
	case DIFFICULTIES_EASY:
		cars_spawn_max = 3;
		break;

	case DIFFICULTIES_NORMAL:
		normal_diff_lane = get_rand_between(lanes_cars[0], lanes_cars[LANES_CAR_TOTAL - 1]);
		cars_spawn_max = 4;
		break;

	case DIFFICULTIES_HARD:
		hard_diff_lane_1 = get_rand_between(lanes_cars[0], lanes_cars[2]);
		hard_diff_lane_2 = get_rand_between(lanes_cars[3], lanes_cars[4]);
		cars_spawn_max = 5;
		break;
	}
}

static void cars_update(void)
{
	// se busca spawnear entre CARS_SPAWN_MIN y cars_spawn_max autos cada CARS_SPAWN_FRAMES frames
	int new_quota = ((game_frames % CARS_SPAWN_FRAMES) ? 0 : get_rand_between(CARS_SPAWN_MIN, cars_spawn_max));

	int i, used;

	// cuento cuantos autos usados hay
	for (i = 0, used = 0; i < CARS_MAX_USED; i++)
		used += car[i].used;

	for (i = 0; i < CARS_MAX_USED; i++)
	{
		// Spawneo de autos.
		if (!car[i].used && new_quota > 0 && used < CARS_MAX_USED) // Lugar libre?
		{
			// Asigno carril.
			car[i].lane = lanes_cars[get_rand_between(0, LANES_CAR_TOTAL - 1)];

			// Coordenada 'y' en funcion del carril
			car[i].y = CELL_H * car[i].lane + CAR_OFFSET_Y;

			// Velocidad menor en rutas mas alejadas
			car[i].dx = car[i].lane - (MAX_LANES - LANES_CAR_TOTAL) + CARS_BASE_SPEED;
			// car[i].dx = CARS_BASE_SPEED;

			// Asigno tipos.
			car[i].type = get_rand_between(0, CAR_TYPE_N - 1);

			// Defino los largos correspondientes,
			switch (car[i].type)
			{
			case CAR_POLICE:
			case CAR_YELLOW:
			case CAR_BLUE:
				car[i].length = CAR_W;
				break;
			case TRUCK_FIRE:
				car[i].length = CAR_TRUCK_FIRE_W;
				break;
			case TRUCK:
				car[i].length = CAR_TRUCK_W;
				break;
			default:
				break;
			}

			// Inicializo el contador;
			car[i].count = 0;

			// Inicializo el flag.
			car[i].fast = 0;

			// en pares...
			if (!(car[i].lane % 2))
			{
				// coordenada de inicio
				car[i].x = -car[i].length;
			}

			// en impares...
			else
			{
				// coordenada de inicio
				car[i].x = DISPLAY_W;

				// hacia el otro lado
				car[i].dx *= (-1);
			}

			int p;
			bool check; // para confirmar asignacion de lane
			for (p = 0, check = true; p < CARS_MAX_USED; p++)
			{
				// si no es el mismo auto, y ese otro esta usado, y coinciden en lane...
				if (p != i && car[p].used && car[p].lane == car[i].lane)
				{
					// si colisiona con algun otro auto...
					if (collide(
							car[i].x - CARS_EXTRA_SEPARATOR,
							car[i].y,
							car[i].x + car[i].length + CARS_EXTRA_SEPARATOR, // Es el mas largo.
							car[i].y + CAR_H,
							car[p].x,
							car[p].y,
							car[p].x + car[p].length,
							car[p].y + CAR_H))
					{
						// no spawnea
						check = false;
						break;
					}
				}
			}

			// si se puede spawnear...
			if (check)
			{
				// Pasa a usado
				car[i].used = true;
				used++;
				new_quota--;
			}

			// si no se puede spawnear...
			else
			{
			}
		}

		// si el auto esta usado...
		else if (car[i].used)
		{
			// Carril con velocidad variable
			if (car[i].count < CAR_WAIT_INCREASE)
			{
				switch (game_data_get_diff())
				{
				case DIFFICULTIES_EASY:
					break;

				case DIFFICULTIES_NORMAL:
					if (car[i].lane == normal_diff_lane)
					{
						if (!(game_frames % CAR_SP_CH_WAIT))
						{
							if (car[i].fast == 0)
							{
								car[i].dx = car[i].lane - (MAX_LANES - LANES_CAR_TOTAL) + CARS_BASE_SPEED + CAR_SPEED_INCREASE;
								if (car[i].lane % 2)
									car[i].dx *= (-1);
								car[i].fast = 1;
							}
							else
							{
								car[i].dx = car[i].lane - (MAX_LANES - LANES_CAR_TOTAL) + CARS_BASE_SPEED;
								if (car[i].lane % 2)
									car[i].dx *= (-1);
								car[i].fast = 0;
							}
						}
					}
					break;
				case DIFFICULTIES_HARD:
					if ((car[i].lane == hard_diff_lane_1) || (car[i].lane == hard_diff_lane_2))
					{
						if (!(game_frames % CAR_SP_CH_WAIT))
						{
							if (car[i].fast == 0)
							{
								car[i].dx = car[i].lane - (MAX_LANES - LANES_CAR_TOTAL) + CARS_BASE_SPEED + CAR_SPEED_INCREASE;
								if (car[i].lane % 2)
									car[i].dx *= (-1);
								car[i].fast = 1;
							}
							else
							{
								car[i].dx = car[i].lane - (MAX_LANES - LANES_CAR_TOTAL) + CARS_BASE_SPEED;
								if (car[i].lane % 2)
									car[i].dx *= (-1);
								car[i].fast = 0;
							}
						}
					}
				default:
					break;
				}
			}
			else
				car[i].count++;

			// Desplazamiento
			car[i].x += car[i].dx;

			// chequea si llego a los limites
			if ((car[i].dx > 0 && car[i].x >= DISPLAY_W) || (car[i].dx < 0 && car[i].x <= -car[i].length))
			{
				car[i].used = false;
				used--;
			}

			// printf("~car%d lane%d dx%d~\n", i, car[i].lane, car[i].dx);
		}
	}
}

static void cars_draw()
{
	int i;
	bool flag;

	ALLEGRO_BITMAP *temp_bitmap = NULL;

	for (i = 0; i < CARS_MAX_USED; i++)
	{
		if (car[i].used)
		{
			if (car[i].dx < 0)
				flag = ALLEGRO_FLIP_HORIZONTAL;
			else
				flag = 0;

			temp_bitmap = sprites.car[car[i].type];

			// Dibujo los autos en sus carriles.
			al_draw_bitmap(temp_bitmap, car[i].x, car[i].y, flag);

#ifdef DEBUG_ENTITIES_TEXT
			// Dibujo hitbox
			allegro_draw_hitbox(car[i].x, car[i].y, car[i].length, CAR_H);
#endif
		}
	}

#ifdef DEBUG_ENTITIES_TEXT
	// coordenadas
	int space;
	for (i = 0, space = 200; i < CARS_MAX_USED; i++, space += 20)
	{
		// al_draw_textf(allegro_get_var_font(), al_map_rgb(255, 255, 255), 0, space, 0, "N°:%d X:%d Y:%d dx:%d", i, car[i].x, car[i].y, car[i].dx);
		al_draw_textf(allegro_get_var_font(), al_map_rgb(255, 255, 255), 0, space, 0, "Lane:%d dx:%d", car[i].lane, car[i].dx);
	}
#endif
}

static void turtles_init(void)
{
	int i;
	for (i = 0; i < TURTLES_MAX_USED; i++)
	{
		turtle_pack[i].used = false;
	}
}

static void turtles_update(void)
{
	int new_quota = ((game_frames % TURTLES_SPAWN_FRAMES) ? 0 : get_rand_between(TURTLES_SPAWN_MIN, TURTLES_SPAWN_MAX));

	int i, used;

	for (i = 0, used = 0; i < TURTLES_MAX_USED; i++)
	{
		if (turtle_pack[i].used)
			used++;
	}

	for (i = 0; i < TURTLES_MAX_USED; i++)
	{
		// Spawneo de turtle_packs
		if (!turtle_pack[i].used && new_quota > 0 && used < TURTLES_MAX_USED) // Lugar libre?
		{

			// defino tortugas en el pack
			turtle_pack[i].turtles_in_pack = get_rand_between(TURTLES_MIN_PER_PACK, TURTLES_MAX_PER_PACK);

			// calculo ancho del pack
			turtle_pack[i].wide = TURTLE_SIDE * turtle_pack[i].turtles_in_pack;

			// Asigno carril.
			turtle_pack[i].lane = lanes_turtles[get_rand_between(0, LANES_TURTLE_TOTAL - 1)];

			// Coordenada 'y' en funcion del carril
			turtle_pack[i].y = CELL_H * turtle_pack[i].lane;

			// Velocidad
			// turtle_pack[i].dx = lanes_turtles[LANES_TURTLE_TOTAL- turtle_pack[i].lane + 1];
			turtle_pack[i].dx = TURTLES_BASE_SPEED;

			// en pares...
			if (!(turtle_pack[i].lane % 2))
			{
				// coordenada de inicio
				turtle_pack[i].x = -turtle_pack[i].wide;
			}

			// en impares...
			else
			{
				// coordenada de inicio
				turtle_pack[i].x = DISPLAY_W;

				// hacia el otro lado
				turtle_pack[i].dx *= (-1);
			}

			int p;
			bool check; // para confirmar asignacion de lane
			for (p = 0, check = true; p < TURTLES_MAX_USED; p++)
			{
				// si no es el mismo pack, y ese otro esta usado, y coinciden en lane...
				if (p != i && turtle_pack[p].used && turtle_pack[p].lane == turtle_pack[i].lane)
				{
					// si colisiona con algun otro pack...
					if (collide(
							turtle_pack[i].x - TURTLES_EXTRA_SEPARATOR,
							turtle_pack[i].y,
							turtle_pack[i].x + turtle_pack[i].wide + TURTLES_EXTRA_SEPARATOR,
							turtle_pack[i].y + TURTLE_SIDE,
							turtle_pack[p].x,
							turtle_pack[p].y,
							turtle_pack[p].x + turtle_pack[p].wide,
							turtle_pack[p].y + TURTLE_SIDE))
					{
						// no spawnea
						check = false;
						break;
					}
				}
			}

			// si se puede spawnear...
			if (check)
			{
				// Pasa a usado
				turtle_pack[i].used = true;
				used++;

				// se inicializa el contador de frames
				turtle_pack[i].fx.frame = 0;
				turtle_pack[i].fx.cont = 1;
				turtle_pack[i].fx.timeout = 0;
				// fuera del agua
				turtle_pack[i].state = TURTLE_STATE_SURFACE;

				new_quota--;
			}

			// si no se puede spawnear...
			else
			{
			}
		}

		// si el pack esta usado...
		else if (turtle_pack[i].used)
		{
			// desplaza
			turtle_pack[i].x += turtle_pack[i].dx;

			switch (turtle_pack[i].state)
			{
			case TURTLE_STATE_SURFACE:
				if (!(turtle_pack[i].fx.cont++ % TURTLES_FRAME_TIMEOUT_SURFACE))
					turtle_pack[i].fx.frame++;

				// si no esta inicializado, inicializo timeout
				if (!turtle_pack[i].fx.timeout)
					turtle_pack[i].fx.timeout = get_rand_between(TURTLES_SURFACE_FRAMES_MIN, TURTLES_SURFACE_FRAMES_MAX);

				// pasa a agua
				if (!(turtle_pack[i].fx.cont % turtle_pack[i].fx.timeout))
				{
					turtle_pack[i].state = TURTLE_STATE_GOING_DOWN;
					turtle_pack[i].fx.frame = 7;
					turtle_pack[i].fx.timeout = 0;
					turtle_pack[i].fx.cont = 1;
				}

				// Reinicia animacion
				else if (turtle_pack[i].fx.frame == 7)
					turtle_pack[i].fx.frame = 0;

				break;

			case TURTLE_STATE_GOING_DOWN:
				if (!(turtle_pack[i].fx.cont++ % TURTLES_FRAME_TIMEOUT_GOING_DOWN))
					turtle_pack[i].fx.frame++;

				if (turtle_pack[i].fx.frame == 9)
				{
					turtle_pack[i].state = TURTLE_STATE_WATER;
					turtle_pack[i].fx.cont = 1;
				}

				break;

			case TURTLE_STATE_WATER:
				if (!(turtle_pack[i].fx.cont++ % TURTLES_FRAME_TIMEOUT_WATER))
					turtle_pack[i].fx.frame++;

				// si no esta inicializado, inicializo timeout
				if (!turtle_pack[i].fx.timeout)
					turtle_pack[i].fx.timeout = get_rand_between(TURTLES_WATER_FRAMES_MIN, TURTLES_WATER_FRAMES_MAX);

				// pasa a fuera
				if (!(turtle_pack[i].fx.cont % turtle_pack[i].fx.timeout))
				{
					turtle_pack[i].state = TURTLE_STATE_GOING_UP;
					turtle_pack[i].fx.frame = 10;
					turtle_pack[i].fx.timeout = 0;
					turtle_pack[i].fx.cont = 1;
				}

				// Reinicia animacion
				else if (turtle_pack[i].fx.frame == 11)
					turtle_pack[i].fx.frame = 9;

				break;

			case TURTLE_STATE_GOING_UP:
				if (!(turtle_pack[i].fx.cont++ % TURTLES_FRAME_TIMEOUT_GOING_UP))
					turtle_pack[i].fx.frame--;

				if (turtle_pack[i].fx.frame == 7)
				{
					turtle_pack[i].fx.frame = 6;
					turtle_pack[i].state = TURTLE_STATE_SURFACE;
					turtle_pack[i].fx.cont = 1;
				}

				break;

			default:
				break;
			}

			// chequea si llego a los limites
			if ((turtle_pack[i].dx > 0 && turtle_pack[i].x >= DISPLAY_W) || (turtle_pack[i].dx < 0 && turtle_pack[i].x <= -turtle_pack[i].wide))
			{
				turtle_pack[i].used = false;
				used--;
			}

			// printf("~turtle_pack%d lane%d dx%d~\n", i, turtle_pack[i].lane, turtle_pack[i].dx);
		}
	}
}

static void turtles_draw(void)
{
	int i, j, flag;
	for (i = 0; i < TURTLES_MAX_USED; i++)
	{
		if (turtle_pack[i].used)
		{
			for (j = 0; j < turtle_pack[i].turtles_in_pack; j++)
			{
				if (turtle_pack[i].dx < 0)
					flag = ALLEGRO_FLIP_HORIZONTAL;
				else
					flag = 0;

				al_draw_bitmap(sprites.turtle[turtle_pack[i].fx.frame], turtle_pack[i].x + TURTLE_SIDE * j, turtle_pack[i].y, flag);
			}

#ifdef DEBUG_ENTITIES_TEXT
			// Dibujo hitbox
			allegro_draw_hitbox(turtle_pack[i].x, turtle_pack[i].y, turtle_pack[i].wide, TURTLE_SIDE);
#endif
		}
	}

#ifdef DEBUG_ENTITIES_TEXT
	// coordenadas
	int space;
	for (i = 0, space = 350; i < TURTLES_MAX_USED; i++, space += 10)
	{
		al_draw_textf(allegro_get_var_font(), al_map_rgb(200, 50, 50), 0, space, 0, "N°:%d X:%d Y:%d", i, turtle_pack[i].x, turtle_pack[i].y);
	}
#endif
}

static void coin_init(void)
{
	coin.used = false;
	coin.y = CELL_H + SPRITE_COIN_OFFSET_XY + GOAL_ROW_OFFSET_Y_FIX;

	coin.fx.blink_timer = 0;
	coin.fx.timeout = 0;
	coin.fx.flag = false;
	coin.fx.cont = 1;
}

static void coin_update(void)
{
	if (!coin.used)
	{
		// si no esta inicializado, inicializo timeout para spawneo
		if (!coin.fx.timeout)
			coin.fx.timeout = get_rand_between(COIN_SPAWN_FRAMES_MIN, COIN_SPAWN_FRAMES_MAX);

		if (!(coin.fx.cont % coin.fx.timeout))
		{
			// calculo de coordenada x para alguno de los puntos de llegada
			int temp_goal = get_rand_between(0, MAX_GOALS - 1);

			// si el goal está libre...
			if (!game_data_get_goal_state(temp_goal))
			{
				allegro_sound_play_effect_coin_drop();

				coin.x = CELL_W * goal_cols[temp_goal] + SPRITE_COIN_OFFSET_XY - 1;
				// marcado como usado
				coin.used = true;
				// desinicializo el timeout
				coin.fx.timeout = 0;

				coin.fx.blink_timer = 0;
				coin.fx.cont = 1;
				coin.fx.frame_cont = 0;
			}

			// si no, cuando pasa otro timeout se intenta de nuevo
			else
			{
			}
		}
	}

	else
	{
		// timeout para despawneo
		if (!coin.fx.timeout)
			coin.fx.timeout = get_rand_between(COIN_DESPAWN_FRAMES_MIN, COIN_DESPAWN_FRAMES_MAX);

		if (++coin.fx.blink_timer > coin.fx.timeout - COIN_FRAMES_TO_WARN_A)
		{
			if (coin.fx.blink_timer > coin.fx.timeout - COIN_FRAMES_TO_WARN_B)
			{
				if (!(coin.fx.cont % COIN_WARNING_FRAMES_B))
					coin.fx.flag = !coin.fx.flag;
			}
			else
			{
				if (!(coin.fx.cont % COIN_WARNING_FRAMES_A))
					coin.fx.flag = !coin.fx.flag;
			}
		}

		if (!(game_frames % COIN_FRAME_RATE))
		{
			if (++coin.fx.frame_cont == SPRITE_COIN_FRAMES)
				coin.fx.frame_cont = 0;
		}

		// si se puede despawnear
		if (!(coin.fx.cont % coin.fx.timeout))
		{
			// coin no usada
			coin.used = false;

			// desinicializo timeout
			coin.fx.timeout = 0;

			// saco el blinking
			coin.fx.flag = false;

			coin.fx.cont = 1;
		}
	}

	coin.fx.cont++;
}

static void coin_draw(void)
{
	if (coin.used)
	{
		// Si no está el flag, dibujo sprite normalmente
		if (!coin.fx.flag)
			al_draw_bitmap(sprites.coin.frame[coin.fx.frame_cont], coin.x, coin.y, 0);
	}

#ifdef DEBUG_ENTITIES_TEXT

	// hitbox
	allegro_draw_hitbox(coin.x, coin.y, COIN_SIDE, COIN_SIDE);

	// coordenadas
	int space = 500;
	al_draw_textf(allegro_get_var_font(), al_map_rgb(200, 50, 50), 0, space, 0, "Coin ~ X:%d Y:%d", coin.x, coin.y);
#endif
}

static void fix_frog_coord_y(void)
{
	int y = (frog.y - FROG_OFFSET_Y);

	int y_values[ROWS];

	int i;

	// Carga valores "correctos" de y
	for (i = 1; i < ROWS - 1; i++)
		y_values[i] = i * CELL_H;

	int temp_a, temp_b;
	for (i = 1; i < ROWS - 1; i++)
	{
		temp_a = y - y_values[i];

		if (temp_a > 0)
			continue;
		if (temp_a == 0)
			break;

		temp_b = y_values[i - 1] - y;

		//"si está más cerca de la fila 'i' que de la 'i+1"
		if (temp_a <= temp_b)
			frog.y = y_values[i - 1] + FROG_OFFSET_Y;
		else
			frog.y = y_values[i] + FROG_OFFSET_Y;

		break;
	}
}

static bool is_frog_in_goal(void)
{
	bool state = false;
	int x = frog.x;

	int i, x_col;
	for (i = 0; i < MAX_GOALS; i++)
	{
		// Coordenada top left del punto de llegada
		x_col = goal_cols[i] * CELL_W;

		// Calculo para ver si entro bien o no
		if ((x > x_col - GOAL_ROW_MARGIN_TO_REACH) &&
			((x + FROG_W) < x_col + CELL_W + GOAL_ROW_MARGIN_TO_REACH))
		{
			// coodenada X aceptable
			state = true;
			break;
		}
	}

	// Si coincide en coordenada y el goal esta libre...
	if (state && !game_data_get_goal_state(i))
	{
		// marca el goal como completo
		game_data_set_goal(i);
	}
	else
	{
		// no llego a un goal valido
		state = false;
	}

	return state;
}

static void corpse_init(int x, int y)
{
	corpse_fx.flag = true;
	corpse_fx.timer = 1;
	corpse_fx.x = x - FROG_OFFSET_X + SPRITE_DEAD_OFFSET;
	corpse_fx.y = y - FROG_OFFSET_Y + SPRITE_DEAD_OFFSET;
}

static void corpse_update(void)
{
	if (corpse_fx.flag)
	{
		if (!(corpse_fx.timer++ % SPRITE_DEAD_TIMEOUT))
			corpse_fx.flag = false;
	}
}

static void corpse_draw(void)
{
	if (corpse_fx.flag)
		al_draw_bitmap(sprites.dead, corpse_fx.x, corpse_fx.y, 0);
}

static void splash_init(int x, int y)
{
	splash_fx.flag = true;
	splash_fx.cont = 1;
	splash_fx.frame_cont = 0;
	splash_fx.x = x - FROG_OFFSET_X + SPRITE_SPLASH_OFFSET_X;
	splash_fx.y = y - FROG_OFFSET_Y + SPRITE_SPLASH_OFFSET_Y;
}

static void splash_update(void)
{
	if (splash_fx.flag)
	{
		if (!(splash_fx.cont % SPRITE_SPLASH_RATE))
		{
			if (++splash_fx.frame_cont == SPRITE_SPLASH_FRAMES)
			{
				splash_fx.frame_cont = 0;
				splash_fx.flag = false;
			}
		}

		splash_fx.cont++;
	}
}

static void splash_draw(void)
{
	if (splash_fx.flag)
		al_draw_bitmap(sprites.splash.frame[splash_fx.frame_cont], splash_fx.x, splash_fx.y, 0);
}

/**
 * @file 	game_data.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo game_data. Inicializa, actualiza y muestra los datos
 * 			del juego en PC.
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "game_data.h"
#include <stdio.h>
#include <time.h>
#include "geometry.h"
#include "allegro_stuff.h"

/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

#define MAX_NAME_CHAR 20

#define MAX_LIVES 3

#define SCORE_PER_GOAL 500		// puntaje por llegar a la meta
#define SCORE_PER_GOAL_COIN 750 // puntaje por llegar a la meta con coin
#define SCORE_PER_RUN 1000		// puntaje por completar una run

#define INITIAL_RUN_TIME_LEFT 60 //tiempo inicial de una partida
#define RUN_TIME_LEFT_REDUCE_FACTOR_A 2 //reduccion A
#define RUN_TIME_LEFT_REDUCE_LIMIT_A 5 //por cuantas runs usar la reduccion A
#define RUN_TIME_LEFT_REDUCE_FACTOR_B 5 //reduccion B
#define RUN_TIME_LEFT_REDUCE_UNTIL 10 //tiempo mínimo a tener

#define EXTRA_TIME_PER_GOAL 10		 // 10s extras por llegar a una meta
#define EXTRA_TIME_PER_BONUS_GOAL 15 // 15s extras por llegar a una meta con coin

#define TIME_LEFT_WARNING 10 // warning 10s antes del timeout

#define HUD_EXTRA_INFO_TIMING 120 // frames que duran los mensajes emergentes
#define HUD_EXTRA_INFO_RATE 1	  // "velocidad" de desplazamiento de mensajes

/*******************************************************************************
 * ENUMERATIONS AND STRUCTURES AND TYPEDEFS
 ******************************************************************************/

typedef struct
{
	int lives;
	unsigned long long score;
	unsigned long long score_max;

	struct
	{
		int number;	   // numero de run actual
		int time_left; // tiempo restante en la run
		int time;	   // tiempo de la run actual
		long time_ref; // referencia de tiempo global de la run
	} run;

	unsigned long frames;
	int timer_in_sec;

	int difficulty;

	char name[MAX_NAME_CHAR];

	unsigned char flag;

	bool goals[MAX_GOALS];

} data_t;

enum DATA_FLAGS
{
	DATA_FLAG_STARTING,
	DATA_FLAG_NEXT_RUN,
	DATA_FLAG_TIME_EXCEEDED,
	DATA_FLAG_GAME_OVER
};

// Tipos de mensajes emergentes en el HUD
enum HUD_EXTRAS
{
	HUD_EXTRA_TIME,
	HUD_EXTRA_SCORE,
	HUD_EXTRA_RUN,
	HUD_EXTRAS_MAX
};

// Estructura para el manejo de mensajes emergentes en el HUD
static struct
{
	bool flag;	 // Activado ó no
	int value;	 // Valor extra a mostrar
	int timer;	 // Contador interno para dejar de mostrar
	int shifter; // Contador interno para desplazar el mensaje verticalmente
} hud_extra_stuff[HUD_EXTRAS_MAX];

/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/**
 * @brief Inicializa datos internos
 *
 */
static void data_init(void);

/**
 * @brief Actualiza datos internos
 *
 */
static void data_update(void);

/**
 * @brief Dibuja el HUD (datos in-game)
 *
 */
static void hud_draw(void);

/**
 * @brief Dibuja "ranas facing down" en los puntos de llegada ya alcanzados
 *
 */
static void draw_reached_goals(void);

/**
 * @brief Configura variables para comenzar otra run
 *
 */
static void next_run(void);

/**
 * @brief Configura el HUD para mostrar mensaje emergente de tiempo ganado
 *
 * @param extra Tiempo extra
 */
static void trigger_show_adding_time(int extra);

/**
 * @brief Configura el HUD para mostrar mensaje emergente de score ganado
 * 
 * @param extra Score extra
 */
static void trigger_show_adding_score(int extra);

/**
 * @brief Configura el HUD para mostrar mensaje emergente de run incrementada
 * 
 */
static void trigger_show_adding_run(void);

/**
 * @brief Muestra tiempo extra en el HUD
 * 
 */
static void draw_extra_time(void);

/**
 * @brief Muestra score extra en el HUD
 * 
 */
static void draw_extra_score(void);

/**
 * @brief Muestra run ganada en el HUD
 * 
 */
static void draw_extra_run(void);

/**
 * @brief Reduce el nuevo tiempo inicial de un run al superar una
 * 
 */
static void progress_run_time_left(void);

/**
 * @brief Checkea si queda un solo goal por completar
 * 
 * @return true Si
 * @return false No
 */
static bool is_last_goal(void);

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

// Datos internos del juego
static data_t data;

// Referencia temporal del inicio del juego
static long time_ref;

static int char_h; // altura de un caracter
static int char_w; // ancho de un caracter

static ALLEGRO_COLOR text_color;

// Flag para triggear sonido de poco tiempo
static bool flag_low_time_warning;

// Auxiliar para hacer acciones en los cambios de segundos
static int last_loop_time;

// Tiempo restante inicial de una nueva run. Se puede modificar externamente
static int new_run_time_left;

// Auxiliar para mostrar el score gradualmente en el HUD
static unsigned long long score_display;

// Score maximo no actualizado en game over
static unsigned long long max_score_no_updated;

/*******************************************************************************
 *******************************************************************************
            GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void game_data_init(void)
{
	time_ref = time(NULL);

	char_h = allegro_get_var_font_h();
	char_w = allegro_get_var_font_w();

	text_color = al_map_rgb(255, 255, 255);

	flag_low_time_warning = false;

	new_run_time_left = INITIAL_RUN_TIME_LEFT;

	score_display = 0;

	int i;
	for(i = 0; i < HUD_EXTRAS_MAX; i++)
		hud_extra_stuff[i].flag = false;

	data_init();
}

void game_data_update(void)
{
	data_update();

	if (data.flag == DATA_FLAG_NEXT_RUN)
	{
		next_run();
		data.flag = DATA_FLAG_STARTING;
	}

	if (data.run.time_left == TIME_LEFT_WARNING && !flag_low_time_warning)
	{
		allegro_sound_play_effect_low_time();

		flag_low_time_warning = true;
	}
	else if (data.run.time_left < TIME_LEFT_WARNING)
		flag_low_time_warning = false;

	if (max_score_no_updated != data.score_max)
		max_score_no_updated = data.score_max;

	if (data.run.time_left == 0)
	{
		// data.flag = DATA_FLAG_TIME_EXCEEDED;
		game_data_subtract_live();
		allegro_sound_play_effect_no_time();
		data.flag = DATA_FLAG_GAME_OVER;
	}

	if (data.lives == 0)
	{
		data.flag = DATA_FLAG_GAME_OVER;
	}
	
}

void game_data_draw(void)
{
	hud_draw();
	draw_reached_goals();
}

int game_data_get_lives(void)
{
	return (data.lives);
}

void game_data_subtract_live(void)
{
	data.lives--;
}

unsigned long long game_data_get_score(void)
{
	return (data.score);
}

void game_data_add_score(void)
{
	unsigned long long adder = SCORE_PER_GOAL + 250*(game_data_get_diff() - 1);

	data.score += adder;
	if(!is_last_goal())
		trigger_show_adding_score(adder);
}

void game_data_add_score_bonus(void)
{
	unsigned long long adder = SCORE_PER_GOAL_COIN + 250*(game_data_get_diff() - 1);

	data.score += adder;
	if(!is_last_goal())
		trigger_show_adding_score(adder);
}

void game_data_set_score_max(unsigned long long score)
{
	data.score_max = score;
}

unsigned long long game_data_get_score_max(void)
{
	return data.score_max;
}

int game_data_get_run_number(void)
{
	return (data.run.number);
}

void game_data_next_run(void)
{
	data.flag = DATA_FLAG_NEXT_RUN;
}

int game_data_get_run_time_left(void)
{
	return (data.run.time_left);
}

void game_data_add_run_time_goal(void)
{
	data.run.time_left += EXTRA_TIME_PER_GOAL;
	
	if(!is_last_goal())
		trigger_show_adding_time(EXTRA_TIME_PER_GOAL);
}

void game_data_add_run_time_goal_bonus(void)
{
	data.run.time_left += EXTRA_TIME_PER_BONUS_GOAL;

	if(!is_last_goal())
		trigger_show_adding_time(EXTRA_TIME_PER_BONUS_GOAL);
}

unsigned long game_data_get_frames(void)
{
	return (data.frames);
}

int game_data_get_timer_in_sec(void)
{
	return (data.timer_in_sec);
}

void game_data_set_diff(int diff)
{
	data.difficulty = diff;
}

int game_data_get_diff(void)
{
	return (data.difficulty);
}

void game_data_clear_name(void)
{
	memset(data.name, 0, MAX_NAME_CHAR);
}

void game_data_overwrite_name(char *name)
{
	int i;
	for(i = 0; name[i] != '\0'; i++)
		data.name[i] = name[i];

	//strcpy(data.name, name);
}

void game_data_add_name_letter(char letter)
{
	int length = strlen(data.name);

	if ((letter == ALLEGRO_KEY_BACKSPACE) && (length > 0))
	{
		data.name[length - 1] = 0;
	}

	else if (letter >= ALLEGRO_KEY_A && letter <= ALLEGRO_KEY_Z && length < MAX_NAME_CHAR)
	{
		letter += '@';
		data.name[length] = letter;
		data.name[length + 1] = 0;
	}
}

char *game_data_get_name(void)
{
	return (data.name);
}

bool game_data_get_goal_state(unsigned int goal)
{
	return data.goals[goal];
}

void game_data_set_goal(unsigned int goal)
{
	data.goals[goal] = true;
}

void game_data_reset_goals(void)
{
	int i;
	for (i = 0; i < MAX_GOALS; i++)
		data.goals[i] = false;
}

bool game_data_get_game_over_flag(void)
{
	if (data.flag == DATA_FLAG_GAME_OVER)
		return true;
	else
		return false;
}

bool game_data_are_goals_full(void)
{
	bool state = true;

	int i;
	for (i = 0; i < MAX_GOALS; i++)
	{
		// si alguno esa vacio...
		if (!data.goals[i])
		{
			state = false;
			break;
		}
	}

	return state;
}

unsigned long long game_data_get_old_max_score(void)
{
	return max_score_no_updated;
}

/*******************************************************************************
 *******************************************************************************
            LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

static void data_init(void)
{
	data.frames = 0;
	data.lives = MAX_LIVES;
	data.run.number = 0;
	data.run.time_left = new_run_time_left;
	data.run.time = 0;
	data.run.time_ref = time(NULL);
	data.score = 0;
	data.timer_in_sec = 0;

	data.flag = DATA_FLAG_STARTING;

	last_loop_time = 0;

	game_data_reset_goals();
}

static void data_update(void)
{
	data.frames++;

	if(entities_get_tutorial())
	{
		// diferencia entre el tiempo actual y el de referencia
		data.timer_in_sec = time(NULL) - time_ref;
		data.run.time = time(NULL) - data.run.time_ref;

		if (data.run.time > last_loop_time)
		{
			data.run.time_left--;
			last_loop_time++;
		}
		last_loop_time = data.run.time;
	}
	
}

static void hud_draw(void)
{
	// Dibuja la puntuacion en pantalla.

	int i;

	// Graduacion del score a mostrar para que vaya incrementando de apoco
	if (score_display != data.score)
	{
		int shifter;

		for (i = 2, shifter = 0; i > 0; i--)
		{
			shifter = 1 << i;
			if (score_display <= (data.score - shifter))
				score_display += shifter;
		}
	}

	al_draw_textf(
		allegro_get_var_font(),
		text_color,
		1, 1, // Arriba a la izquierda.
		0,
		"Score: %06lld", // 6 cifras (por ahi es mucho).
		score_display);

	draw_extra_score();

	// Dibuja el numero de vuelta.
	al_draw_textf(
		allegro_get_var_font(),
		text_color,
		1, CELL_H - char_h - 5, // Para que quede abaj de la puntuacion en pantalla.
		0,
		"Run: %02d", // 2 cifras. No me acuerdo si esta bien asi.
		data.run.number);

	draw_extra_run();

	// Segundos.
	al_draw_textf(
		allegro_get_var_font(),
		text_color,
		al_get_text_width(allegro_get_var_font(), "Score: xxxxxx") + 3 * char_w, 1,
		0,
		"Played Time: %04d",
		data.timer_in_sec);

	// Tiempo restante
	al_draw_textf(
		allegro_get_var_font(),
		text_color,
		al_get_text_width(allegro_get_var_font(), "Score: xxxxxx") + 3 * char_w,
		CELL_H - char_h - 5,
		0,
		"Time Left: %03d",
		data.run.time_left);

	draw_extra_time();

	// Dibuja vidas.
	for (int i = 0; i < data.lives; i++) // No se si la rana tiene 'frog.lives' pero aca va el equivalente.
		al_draw_bitmap(
			sprites.heart,
			DISPLAY_W - 100 + SPRITE_SIZE_HEART * (data.lives - i - 1),
			(CELL_H - char_h - 5) / 2,
			0);
}

static void draw_reached_goals(void)
{
	int i;
	for (i = 0; i < MAX_GOALS; i++)
	{
		// si algun goal fue alcanzado...
		if (data.goals[i])
			al_draw_bitmap(sprites.frog[6],
						   goal_cols[i] * CELL_W + FROG_OFFSET_X - 1,
						   CELL_H + FROG_OFFSET_Y + GOAL_ROW_OFFSET_Y_FIX,
						   0);
	}
}

static void next_run(void)
{
	data.run.number++;

	progress_run_time_left();
	data.run.time_left = new_run_time_left;

	data.run.time = 0;
	data.run.time_ref = time(NULL);

	unsigned long long adder = SCORE_PER_RUN + 250*(game_data_get_diff() - 1);

	data.score += adder;
	trigger_show_adding_score(adder);

	last_loop_time = 0;

	flag_low_time_warning = false;

	trigger_show_adding_run();

	game_data_reset_goals();
}

static void trigger_show_adding_time(int extra)
{
	hud_extra_stuff[HUD_EXTRA_TIME].flag = true;
	hud_extra_stuff[HUD_EXTRA_TIME].value = extra;
	hud_extra_stuff[HUD_EXTRA_TIME].timer = 1;
	hud_extra_stuff[HUD_EXTRA_TIME].shifter = 0;
}

static void trigger_show_adding_score(int extra)
{
	hud_extra_stuff[HUD_EXTRA_SCORE].flag = true;
	hud_extra_stuff[HUD_EXTRA_SCORE].value = extra;
	hud_extra_stuff[HUD_EXTRA_SCORE].timer = 1;
	hud_extra_stuff[HUD_EXTRA_SCORE].shifter = 0;
}

static void trigger_show_adding_run()
{
	hud_extra_stuff[HUD_EXTRA_RUN].flag = true;
	hud_extra_stuff[HUD_EXTRA_RUN].value = 1;
	hud_extra_stuff[HUD_EXTRA_RUN].timer = 1;
	hud_extra_stuff[HUD_EXTRA_RUN].shifter = 0;
}

static void draw_extra_time(void)
{
	if (hud_extra_stuff[HUD_EXTRA_TIME].flag)
	{
		al_draw_textf(
			allegro_get_var_font(),
			text_color,
			al_get_text_width(allegro_get_var_font(), "Score: xxxxxx") + 3 * char_w +
				al_get_text_width(allegro_get_var_font(), "Time left: "),
			CELL_H - char_h - 5 + hud_extra_stuff[HUD_EXTRA_TIME].shifter,
			0,
			"%+3d",
			hud_extra_stuff[HUD_EXTRA_TIME].value);

		hud_extra_stuff[HUD_EXTRA_TIME].shifter += HUD_EXTRA_INFO_RATE;

		if (!(hud_extra_stuff[HUD_EXTRA_TIME].timer++ % HUD_EXTRA_INFO_TIMING))
			hud_extra_stuff[HUD_EXTRA_TIME].flag = false;
	}
}

static void draw_extra_score(void)
{
	if (hud_extra_stuff[HUD_EXTRA_SCORE].flag)
	{
		al_draw_textf(
			allegro_get_var_font(),
			text_color,
			1 + al_get_text_width(allegro_get_var_font(), "Score: "),
			1 + hud_extra_stuff[HUD_EXTRA_SCORE].shifter,
			0,
			"%+6d",
			hud_extra_stuff[HUD_EXTRA_SCORE].value);

		hud_extra_stuff[HUD_EXTRA_SCORE].shifter += HUD_EXTRA_INFO_RATE;

		if (!(hud_extra_stuff[HUD_EXTRA_SCORE].timer++ % HUD_EXTRA_INFO_TIMING))
			hud_extra_stuff[HUD_EXTRA_SCORE].flag = false;
	}
}

static void draw_extra_run(void)
{
	if (hud_extra_stuff[HUD_EXTRA_RUN].flag)
	{
		al_draw_textf(
			allegro_get_var_font(),
			text_color,
			1 + al_get_text_width(allegro_get_var_font(), "Run: "),
			CELL_H - char_h - 5 + hud_extra_stuff[HUD_EXTRA_RUN].shifter,
			0,
			"%+2d",
			hud_extra_stuff[HUD_EXTRA_RUN].value);

		hud_extra_stuff[HUD_EXTRA_RUN].shifter += HUD_EXTRA_INFO_RATE;

		if (!(hud_extra_stuff[HUD_EXTRA_RUN].timer++ % HUD_EXTRA_INFO_TIMING))
			hud_extra_stuff[HUD_EXTRA_RUN].flag = false;
	}
}

static void progress_run_time_left(void)
{

	//Si la run es menor a la evaluada...
	if(data.run.number <= RUN_TIME_LEFT_REDUCE_LIMIT_A)
	{
		new_run_time_left -= RUN_TIME_LEFT_REDUCE_FACTOR_A;
		trigger_show_adding_time(-RUN_TIME_LEFT_REDUCE_FACTOR_A);
	}

	//Si el tiempo restante actual es mayor al mínimo establecido...
	else if(new_run_time_left > RUN_TIME_LEFT_REDUCE_UNTIL)
	{
		new_run_time_left -= RUN_TIME_LEFT_REDUCE_FACTOR_B;
		trigger_show_adding_time(-RUN_TIME_LEFT_REDUCE_FACTOR_B);
	}
	
}

static bool is_last_goal(void)
{
	int i, j;
	for(i = 0, j = 0; i < MAX_GOALS; i++)
	{
		if(data.goals[i])
			j++;
	}
	//Si es el ultimo goal...
	if(j == MAX_GOALS)
		return true;
	else
		return false;
}
/**
 * @file 	input.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo input, orientado a PC. Se encarga de procesar
 * 			las entradas en la implementación de PC, y devolverlas adecuadamente
 * 			a la FSM.
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "../../input.h"

#include "allegro_stuff.h"
#include "entities.h"
#include "game_data.h"

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

static ALLEGRO_EVENT *event;

static unsigned char last_key;

/*******************************************************************************
 *******************************************************************************
                        GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

void iniciarEntradas(void)
{
}

event_t leerEntradas(void)
{
	event_t retorno = NO_MOVER;
	// bool queue_no_empty;

	event = allegro_get_next_event();

	if (event != NULL)
	{
		switch ((*event).type)
		{
		case ALLEGRO_EVENT_TIMER:
			allegro_set_var_redraw(true);
			break;

		case ALLEGRO_EVENT_KEY_DOWN:
			last_key = allegro_get_last_key();

			if (last_key != (*event).keyboard.keycode)
			{
				retorno = (*event).keyboard.keycode;
				allegro_set_last_key(retorno);

				switch (retorno)
				{
				case ALLEGRO_KEY_F2:
					allegro_sound_set_stream_gain_up();
					break;

				case ALLEGRO_KEY_F1:
					allegro_sound_set_stream_gain_down();
					break;

				case ALLEGRO_KEY_2:
					allegro_sound_unmute();
					break;

				case ALLEGRO_KEY_1:
					allegro_sound_mute();
					break;

				case ALLEGRO_KEY_4:
					game_data_add_score();
					break;

				case ALLEGRO_KEY_5:
					game_data_add_run_time_goal();
					break;

				case ALLEGRO_KEY_6:
					retorno = GAME_OVER;
					break;

				default:
					break;
				}
			}

			break;

		case ALLEGRO_EVENT_KEY_UP:
			allegro_set_last_key(0);

			break;

		case ALLEGRO_EVENT_DISPLAY_CLOSE:
			retorno = FORCE_SALIR;
			break;

		default:
			break;
		}
	}

	return retorno;
}
/**
 * @file 	fsm.c
 * @authors	AGRIPPINO, ALVAREZ, CASTRO, HEIR
 *
 * @brief 	Source del modulo fsm.
 * 			Administra la máquina de estados, siendo el engine del juego.
 *
 * @copyright Copyright (c) 2022 ~ Ingeniería Electrónica ~ ITBA
 *
 */

/*******************************************************************************
 * INCLUDE HEADER FILES
 ******************************************************************************/

#include "fsm.h"

#include "display.h"
#include "game.h"
#include "menu.h"
#include "input.h"
#include "nombre.h"
#include "sound.h"
#include "ranking.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

/*******************************************************************************
 * CONSTANT AND MACRO DEFINITIONS USING #DEFINE
 ******************************************************************************/

// Codigo para indicar que se llego al final de la tabla de estados
#define FIN_TABLA 0xFF

// Para offsetear estados relativos al menu
#define CTE_OPCION 100

// Delay en us que fixea consumo de CPU
#define FIX_CPU_USAGE_SLEEP_US 500

/*******************************************************************************
 * ENUMERATIONS AND STRUCTURES AND TYPEDEFS
 ******************************************************************************/

typedef struct state_diagram_edge STATE;

// Estructura genérica de una arista
struct state_diagram_edge
{
	event_t evento;
	STATE *proximo_estado;
	void (*p_rut_accion)(void);
};

#pragma region privatePrototypes
/*******************************************************************************
 * FUNCTION PROTOTYPES FOR PRIVATE FUNCTIONS WITH FILE LEVEL SCOPE
 ******************************************************************************/

/**
 * @brief	Thread que se ejecuta desde el inicio de la fsm hasta el cierre
 * 			del programa. Analiza constantemente las entradas externas.
 *
 * @return void*
 */
static void *threadInput(void *ptr);

/**
 * @brief	Thread sobre el cual corre el juego en sí, luego de ingresar
 * 			el nombre.
 *
 * @return void*
 */
static void *threadJuego(void *ptr);

/**
 * @brief	Thread que se ejecuta al estar mostrando el ranking.
 *
 * @return void*
 */
static void *threadDisplayRanking(void *ptr);

/**
 * @brief	Thread que se ejecuta al estar mostrando los creditos.
 *
 * @return void*
 */
static void *threadDisplayCreditos(void *ptr);

/**
 * @brief	Rutina que hace nada. Para mantener la estructura
 * 			de la fsm.
 *
 */
static void do_nothing(void);

/**
 * @brief	Rutina que se ejecuta al presionar enter.
 *
 */
static void procesar_enter_menu(void);

/**
 * @brief	Rutina que se ejecuta al ir al menu principal.
 *
 */
static void ir_a_menu_ppal(void);

/**
 * @brief	Rutina que se ejecuta al pasar a ingresar nombre.
 *
 */
static void ir_a_poniendo_nombre(void);

/**
 * @brief	Rutina que se ejecuta al pasar a seleccionar dificultad.
 *
 */
static void ir_a_seleccionando_dificultad(void);

/**
 * @brief	Rutina que se ejecuta al pasar a ver ranking.
 *
 */
static void ir_a_viendo_ranking(void);

/**
 * @brief	Rutina que se ejecuta al pasar a ver creditos.
 *
 */
static void ir_a_viendo_creditos(void);

/**
 * @brief	Rutina que se ejecuta al finalizar el programa.
 *
 */
static void salir_del_juego(void);

/**
 * @brief 	Rutina que se ejecuta al seleccionar una dificultad.
 *
 */
static void procesar_enter_dificultad(void);

/**
 * @brief	Rutina que se ejecuta al presionar enter en el ranking.
 *
 */
static void procesar_enter_ranking(void);

/**
 * @brief	Rutina que se ejecuta al presionar enter en los creditos.
 *
 */
static void procesar_enter_creditos(void);

/**
 * @brief	Rutina que se ejecuta al iniciar el juego en sí.
 *
 */
static void iniciar_juego(void);

/**
 * @brief	Rutina que se ejecuta al pausar el juego.
 *
 */
static void pausar(void);

/**
 * @brief	Rutina que se ejecuta al continuar el juego luego
 * 			de una pausa.
 *
 */
static void continuar(void);

/**
 * @brief	Rutina que se ejecuta cuando se pierde el juego.
 *
 */
static void procesar_game_over(void);

#pragma endregion privatePrototypes

/*******************************************************************************
 * STATIC VARIABLES AND CONST VARIABLES WITH FILE LEVEL SCOPE
 ******************************************************************************/

// Puntero al estado actual
static STATE *p2CurrentState = NULL;

// Threads implementados
static pthread_t tinput, tjuego, tdisplayranking, tdisplaycreditos;

#pragma region FSM STATES
/*******************************************************************************
 * FSM STATES
 ******************************************************************************/

// Forward declarations de los estados
extern STATE en_menu_ppal[];
extern STATE seleccionando_dificultad[];
extern STATE viendo_ranking[];
extern STATE viendo_creditos[];
extern STATE poniendo_nombre[];
extern STATE jugando[];
extern STATE en_pausa[];
extern STATE en_game_over[];
// Forward declarations de los estados

STATE en_menu_ppal[] =
	{
		{ENTER, en_menu_ppal, procesar_enter_menu},
		{ARRIBA, en_menu_ppal, subirOpcion},
		{ABAJO, en_menu_ppal, bajarOpcion},
		{FORCE_SALIR, NULL, salir_del_juego},
		{CTE_OPCION, poniendo_nombre, ir_a_poniendo_nombre},
		{CTE_OPCION + 1, seleccionando_dificultad, ir_a_seleccionando_dificultad},
		{CTE_OPCION + 2, viendo_ranking, ir_a_viendo_ranking},
		{CTE_OPCION + 3, viendo_creditos, ir_a_viendo_creditos},
		{CTE_OPCION + 4, NULL, salir_del_juego},
		{FIN_TABLA, en_menu_ppal, do_nothing}};

STATE seleccionando_dificultad[] =
	{
		{ENTER, en_menu_ppal, procesar_enter_dificultad},
		{ARRIBA, seleccionando_dificultad, subirOpcion},
		{ABAJO, seleccionando_dificultad, bajarOpcion},
		{FORCE_SALIR, NULL, salir_del_juego},
		{FIN_TABLA, seleccionando_dificultad, do_nothing}};

STATE viendo_ranking[] =
	{
		{ENTER, en_menu_ppal, procesar_enter_ranking},
		{FORCE_SALIR, NULL, salir_del_juego},
		{FIN_TABLA, viendo_ranking, do_nothing}};

STATE viendo_creditos[] =
	{
		{ENTER, en_menu_ppal, procesar_enter_creditos},
		{FORCE_SALIR, NULL, salir_del_juego},
		{FIN_TABLA, viendo_creditos, do_nothing}};

STATE poniendo_nombre[] =
	{
		{ESC, en_menu_ppal, ir_a_menu_ppal},
		{ENTER, jugando, iniciar_juego},
		{ARRIBA, poniendo_nombre, subirLetra},
		{ABAJO, poniendo_nombre, bajarLetra},
		{DCHA, poniendo_nombre, siguienteLetra},
		{FORCE_SALIR, NULL, salir_del_juego},
		{FIN_TABLA, poniendo_nombre, agregarLetra} // Si no coincide el evento con ninguna de las teclas previas, se toam como si se apretase una letra
};

STATE jugando[] =
	{
		{ENTER, en_pausa, pausar},
		{GAME_OVER, en_game_over, procesar_game_over},
		{ARRIBA, jugando, moverAdelante},
		{ABAJO, jugando, moverAtras},
		{IZDA, jugando, moverIzda},
		{DCHA, jugando, moverDcha},
		{FORCE_SALIR, NULL, salir_del_juego},
		{FIN_TABLA, jugando, do_nothing}};

STATE en_pausa[] =
	{
		{ENTER, en_pausa, procesar_enter_menu},
		{ARRIBA, en_pausa, subirOpcion},
		{ABAJO, en_pausa, bajarOpcion},
		{FORCE_SALIR, NULL, salir_del_juego},
		{CTE_OPCION, jugando, continuar},
		{CTE_OPCION + 1, jugando, iniciar_juego},
		{CTE_OPCION + 2, en_menu_ppal, ir_a_menu_ppal},
		{FIN_TABLA, en_pausa, do_nothing}};

STATE en_game_over[] =
	{
		{ENTER, en_game_over, procesar_enter_menu},
		{ARRIBA, en_game_over, subirOpcion},
		{ABAJO, en_game_over, bajarOpcion},
		{FORCE_SALIR, NULL, salir_del_juego},
		{CTE_OPCION, jugando, iniciar_juego},
		{CTE_OPCION + 1, en_menu_ppal, ir_a_menu_ppal},
		{FIN_TABLA, en_game_over, do_nothing}};

#pragma endregion FSM STATES8

/*******************************************************************************
 *******************************************************************************
                        GLOBAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

bool inicializarFsm(void)
{
	p2CurrentState = en_menu_ppal;

	srand(time(NULL));

	iniciarDisplay();
	iniciarMenu();
	iniciarEntradas();
	iniciarSonido();

	iniciarRanking();

	ir_a_menu_ppal();

	pthread_create(&tinput, NULL, threadInput, NULL);

	return true;
}

void fsm(event_t evento_actual)
{
	STATE *aux = p2CurrentState;
	/*
    Mientras el evento actual no coincida con uno "interesante", y mientras no se haya recorrido
    todo el estado...
    */
	while ((aux->evento != evento_actual) && (aux->evento != FIN_TABLA))
		// Verifico con la siguiente posibilidad dentro del mismo estado.
		++aux;

	// Pasa al siguiente estado
	p2CurrentState = aux->proximo_estado;

	// Ejecuta la rutina correspondiente
	(*aux->p_rut_accion)();
}

void fixHighCpuUsage(void)
{
	usleep(FIX_CPU_USAGE_SLEEP_US);
}

/*******************************************************************************
 *******************************************************************************
                        LOCAL FUNCTION DEFINITIONS
 *******************************************************************************
 ******************************************************************************/

static void *threadInput(void *ptr)
{
	while (p2CurrentState)
	{
		event_t entrada = leerEntradas();
		if (entrada != NADA)
			queueInsertar(entrada);

		fixHighCpuUsage();
	}

	return NULL;
}

static void *threadJuego(void *ptr)
{

	reconfigurarDisplayON();

	srand(time(NULL));

	while (p2CurrentState == jugando)
	{
		if (tiempoRefrescoEntidades())
			refrescar();

		actualizarInterfaz();

		fixHighCpuUsage();
	}

	pausarJuego();

	reconfigurarDisplayOFF();

	return NULL;
}

static void *threadDisplayRanking(void *ptr)
{
	reconfigurarDisplayON();

	cargarRanking();

	while (p2CurrentState == viendo_ranking)
		mostrarRanking();

	limpiarDisplay();

	reconfigurarDisplayOFF();

	return NULL;
}

static void *threadDisplayCreditos(void *ptr)
{
	reconfigurarDisplayON();

	cargarCreditos();

	while (p2CurrentState == viendo_creditos)
	{
		mostrarCreditos();
		fixHighCpuUsage();
	}

	reconfigurarDisplayOFF();

	return NULL;
}

static void do_nothing(void)
{
}

static void procesar_enter_menu(void)
{
	reproducirEfecto(EFECTO_MENU_ENTER);
	queueInsertar(CTE_OPCION + getOpcion());
}

static void ir_a_menu_ppal()
{
	limpiarDisplay();
	dejarTexto("MENU", POS_MSJ_MENU, true);
	reproducirMusica(MUSICA_MENU_PPAL);
	int menu[5] = {JUGAR, DIFICULTAD, RANKING, CREDITOS, SALIRTXT};
	setMenu(menu, 5);
	setOpcion(0);
}

static void ir_a_viendo_ranking()
{
	limpiarDisplay();
	reconfigurarDisplayOFF();
	reproducirMusica(MUSICA_RANKING);
	pthread_create(&tdisplayranking, NULL, threadDisplayRanking, NULL);
}

static void ir_a_viendo_creditos(void)
{
	limpiarDisplay();
	reconfigurarDisplayOFF();
	reproducirMusica(MUSICA_CREDITOS);
	pthread_create(&tdisplaycreditos, NULL, threadDisplayCreditos, NULL);
}

static void salir_del_juego()
{
	pthread_join(tinput, NULL);
	reproducirEfecto(EFECTO_SALIENDO);
	sleep(2);
	destruirMenu();
	destruirSonido();
	desiniciarRanking();
	limpiarDisplay();
	queueInsertar(SALIR);
}

static void procesar_enter_ranking(void)
{
	pthread_join(tdisplayranking, NULL);
	reconfigurarDisplayON();
	ir_a_menu_ppal();
}

static void procesar_enter_creditos(void)
{
	pthread_join(tdisplaycreditos, NULL);
	reconfigurarDisplayON();
	ir_a_menu_ppal();
}

static void iniciar_juego(void)
{
	limpiarDisplay();
	char *nombreJugador = devolverNombre();
	if (nombreJugador == NULL)
		setNombre(DEFAULT_PLAYER_NAME);
	else if (nombreJugador[0] == 0)
		setNombre(DEFAULT_PLAYER_NAME);
	else
		setNombre(nombreJugador);

	if (verificarJugadorRanking(getNombre()))
		setMaxPuntos(getJugadorRankingPuntos(getNombre()));

	inicializarJuego();
	reconfigurarDisplayOFF();

	reproducirMusica(MUSICA_JUGANDO);

	reiniciarNivel();
	pthread_create(&tjuego, NULL, threadJuego, NULL);
}

static void ir_a_poniendo_nombre()
{
	limpiarDisplay();
	dejarTexto("INGRESE NOMBRE", POS_MSJ_NOMBRE, true);
	nuevoNombre();
}

static void ir_a_seleccionando_dificultad()
{
	limpiarDisplay();
	dejarTexto("DIFICULTAD", POS_MSJ_DIFICULTAD, true);
	int menu[3] = {FACIL, NORMAL, DIFICIL};
	setMenu(menu, 3);
	setOpcion(0);
}

static void procesar_enter_dificultad(void)
{
	setDificultad(getOpcion());
	reproducirEfecto(EFECTO_MENU_ENTER);
	ir_a_menu_ppal();
}

static void pausar(void)
{
	limpiarDisplay();
	pthread_join(tjuego, NULL);
	reproducirMusica(MUSICA_MENU_PAUSA);
	reconfigurarDisplayON();
	dejarTexto("PAUSA", POS_MSJ_PAUSA, true);
	int menu[3] = {CONTINUAR, REINICIAR, SALIRTXT};
	setMenu(menu, 3);
	setOpcion(0);
}

static void continuar(void)
{
	limpiarDisplay();
	reconfigurarDisplayOFF();
	reproducirMusica(MUSICA_JUGANDO);
	reanudarJuego();
	pthread_create(&tjuego, NULL, threadJuego, NULL);
}

static void procesar_game_over(void)
{
	pthread_join(tjuego, NULL);

	limpiarDisplay();

	reproducirMusica(MUSICA_GAME_OVER);
	reconfigurarDisplayON();

	unsigned long long jugador_puntos = getPuntos();

	if (jugador_puntos > getMaxPuntos())
	{
		reproducirEfecto(EFECTO_NUEVO_MAX_SCORE);

		mostrarTexto("NUEVA PUNTUACION ALTA", POS_MSJ_NEW_HI_SCORE);
		setMaxPuntos(jugador_puntos);

		actualizarRanking(getNombre(), getMaxPuntos());
	}
	limpiarDisplay();
	dejarTexto("FIN DEL JUEGO", POS_MSJ_GAME_OVER, true);
	int menu[2] = {REINICIAR, SALIRTXT};
	setMenu(menu, 2);
	setOpcion(0);
}
